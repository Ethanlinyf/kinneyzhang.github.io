<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title>戈楷旎</title>
<link>https://blog.geekinney.com/</link>
<description>happy hacking emacs!</description>
<Webmaster>kinneyzhang666@gmail.com</Webmaster>
<language>zh-cn</language>
<generator>Emacs OrgMode 9.1.9</generator>
<ttl>5</ttl>
<image>
<url>https://blog.geekinney.com/static/img/favicon.ico</url>
<title>戈楷旎</title>
<link>https://blog.geekinney.com/</link>
<width>32</width>
<height>32</height>
</image>
<item>
<title>解析elisp列表生成html</title>
<link>https://blog.geekinney.com/post/parse-elisp-list-to-html.html</link>
<description>#+TITLE: 解析elisp列表生成html
#+DATE: 2020-03-09
#+CATEGORY: Emacs
#+STARTUP: showall
#+OPTIONS: toc:nil H:2 num:2
#+INCLUDE: ../code/post-info.org
#+TOC: headlines:2

我在使用orgMode搭建静态博客时，需要直接使用elisp生成部分html代码，于是写了这个 =print-html= 函数。主要有两个功能 =print-html-formated= 和 =print-html-unformated= ，前者生成格式化的html，后者生成的html排在一行。

* 使用方法

形如如下列表：

#+BEGIN_SRC emacs-lisp
(setq list
      '(div :class "post-container"
	    (div :class "post-div"
		 (h1 (a :href "url" "text of link"))
		 (p "content of paragraph...")
		 (img :src "src-url" :alt "alt-name")
		 (code (span :class "post-date" "date")))))
#+END_SRC

经过格式化解析 =(print-html-formated list)= 后生成如下html：

#+BEGIN_SRC html
<div class="post-container">
  <div class="post-div">
    <h1>
      <a ref="url">text of link</a>
    </h1>
    <p>content of paragraph...</p>
    <img src="src-url" alt="alt-name"/>
    <code>
      <span class="post-date">date</span>
    </code>
  </div>
</div>
#+END_SRC

* 解析思路
一个典型的输入列表格式为：

#+BEGIN_SRC emacs-lisp
'(tagname :attr1 value1 :attr2 value2 ...
	  text
	  (tagname ...)
	  ...)
#+END_SRC

每个列表的 *第一个元素必须存在且只能是标签名* ，标签名为symbol类型。除了标签名，其余部分都是可选的。如果该html标签存在一些属性，比如 =class= =style= 等, 那么这些 *属性以属性列表(Plist)的形式排列在标签后面* 。至此便构建好了一个带属性的html标签。

那么，列表余下的内容便是该html标签内部的内容。这些内容可能是文本信息，也可能是子级html标签(文本与子标签的先后顺序由html具体结构决定)。子级html的列表同样按照以上思路解析，以此类推....直到整个列表解析完毕。根据以上思路，不难想到解析列表使用了 =递归= 思想。

*输入列表的设计思路：*

使用Plist表示html的属性键值比Alist少写了许多括号，视觉上更简洁；用列表嵌套来表示html的层级关系，在书写时结构清晰。

* 完整代码

#+BEGIN_SRC emacs-lisp
;;; print html with elisp
(defvar print-html--single-tag-list
  '("img" "br" "hr" "input" "meta" "link" "param"))

(defun print-html--get-plist (list)
  "get attributes of a tag"
  (let* ((i 0)
	 (plist nil))
    (while (and (nth i list) (symbolp (nth i list)))
      (setq key (nth i list))
      (setq value (nth (1+ i) list))
      (setq plist (append plist (list key value)))
      (incf i 2))
    plist))

(defun print-html--get-inner (list)
  "get inner html of a tag"
  (let* ((i 0)
	 (inner nil)
	 (plist (print-html--get-plist list)))
    (if (null plist)
	(setq inner list)
      (dolist (p plist)
	(setq inner (remove p list))
	(setq list inner)))
    inner))

(defun print-html--plist->alist (plist)
  "convert plist to alist"
  (if (null plist)
      '()
    (cons
     (list (car plist) (cadr plist))
     (print-html--plist->alist (cddr plist)))))

(defun print-html--insert-html-tag (tag &optional attrs)
  "insert html tag and attributes"
  (let ((tag (symbol-name tag))
	(attrs (print-html--plist->alist attrs)))
    (if (member tag print-html--single-tag-list)
	(progn
	  (insert (concat "<" tag "/>"))
	  (backward-char 2)
	  (dolist (attr attrs)
	    (insert (concat " " (substring (symbol-name (car attr)) 1) "=" "\"" (cadr attr) "\"")))
	  (forward-char 2))
      (progn
	(insert (concat "<" tag ">" "</" tag ">"))
	(backward-char (+ 4 (length tag)))
	(dolist (attr attrs)
	  (insert (concat " " (substring (symbol-name (car attr)) 1) "=" "\"" (cadr attr) "\"")))
	(forward-char 1)))
    ))

(defun print-html--jump-outside (tag)
  "jump outside of html tag"
  (let ((tag (symbol-name tag)))
    (if (member tag print-html--single-tag-list)
	(forward-char 0)
      (forward-char (+ 3 (length tag))))))
;;----------------------------------------
(defun print-html--parse-list-unformated (list)
  "parse elisp to unformated html"
  (let* ((tag (car list))
	 (left (cdr list))
	 (plist (print-html--get-plist left))
	 (inner (print-html--get-inner left))
	 (html ""))
    (with-current-buffer (get-buffer-create "*print html*")
      (print-html--insert-html-tag tag plist)
      (dolist (item inner)
	(if (listp item)
	    (print-html--parse-list-unformated item)
	  (insert item)))
      (print-html--jump-outside tag)
      (setq html (buffer-substring-no-properties (point-min) (point-max))))
    html))
;;----------------------------------------
(defun print-html--if-no-child (inner)
  "judge if html tag has child-tag"
  (let ((no-child t))
    (dolist (item inner)
      (if (listp item)
	  (setq no-child nil)))
    no-child))

(defun print-html--format-html (tag inner)
  "format html tag, tag which has no child show in one line, others are well formated by default. change this function to redesign the format rule."
  (let ((tag (symbol-name tag)))
    (if (member tag print-html--single-tag-list)
	(insert "")
      (progn
	(if (not (print-html--if-no-child inner))
	    (insert "\n"))))))

(defun print-html--parse-list-formated (list)
  "parse elisp to formated html"
  (let* ((tag (car list))
	 (left (cdr list))
	 (plist (print-html--get-plist left))
	 (inner (print-html--get-inner left))
	 (html ""))
    (with-current-buffer (get-buffer-create "*print html*")
      (print-html--insert-html-tag tag plist)
      (print-html--format-html tag inner)
      (dolist (item inner)
	(if (listp item)
	    (print-html--parse-list-formated item)
	  (progn
	    (insert item)
	    (print-html--format-html tag inner))))
      (print-html--jump-outside tag)
      (insert "\n")
      (setq html (buffer-substring-no-properties (point-min) (point-max))))
    html))
;;---------------------------------------
(defun print-html-unformated (LIST)
  (let ((html (print-html--parse-list-unformated LIST)))
    (kill-buffer "*print html*")
    html))

(defun print-html-formated (LIST)
  (let ((html (print-html--parse-list-formated LIST)))
    (kill-buffer "*print html*")
    html))

(defun print-html (FORMATED LIST)
  "print html with elisp. the first elem of LIST is always a html tag, others could be attributes or text content or child tag. the three mentioned above are all optional. if has, attributes must be in first place, followed by text content and child tag."
  (let ((html ""))
    (if FORMATED
	(print-html-formated LIST)
	(print-html-unformated LIST)
      )))
#+END_SRC

=print-html= 函数就是将格式化和非格式化两个函数整合在一起，用 =FORMATED= 变量表示是否格式化显示。

* 应用场景
写 =print-html= 的初衷是为了生成静态博客的首页、归档页、分类页等具有特定格式的页面。因为我对这些页面有布局上的要求，所以orgMode导出的html不能满足需求。使用elisp生成的html可以嵌入在orgMode中，博客的可定制性便高了许多。

除此之外，我还没有想到其他应用场景。所以此番折腾更多的是为了熟悉elisp编程和递归思想。如果还有其他应用场景或拓展的思路，还望读者诸君留言～
</description>
<author>Kinney Zhang</author>
<pubDate>2020-03-09</pubDate>
</item>
<item>
<title>自动生成org blog摘要页</title>
<link>https://blog.geekinney.com/post/auto-generate-blog-digest-page.html</link>
<description>#+TITLE: 自动生成org blog摘要页
#+DATE: 2020-02-22
#+CATEGORY: 博客
#+INCLUDE: "../code/post-info.org"
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+TOC: headlines:2

博客摘要页面可以让读者快速了解文章的大概信息，因此一般将它作为博客首页，其重要性不言而喻。摘要页的主要信息包括：标题，摘要，日期，分类等。每篇文章都手动输入这些文字太麻烦，于是我用elisp自动生成博客摘要页。

先来看看折腾的效果：

https://geekinney-1258820352.cos.ap-hongkong.myqcloud.com/geekblog/img/post-digest-page.png

由于摘要页对排版有一定的要求，所以纯orgMode导出不能满足需求，我采取的办法是在orgMode中直接插入html。和Markdown不同，orgMode中插入html需要将代码包裹在 =#+begin_export html= 和 =#+end_export= 之间。

从上图看出，每篇文章的html代码有相同的格式：

#+BEGIN_SRC html
<div class="post-div">
  <h3><a href="post-url">title</a></h3>
  <p>
    digest......
    <a href="post-url">阅读全文</a>
  </p>
  <code><a href="category-url">category</a></code>
  <span>date</span>
</div>
#+END_SRC

接下来，需要使用elisp获取org文章目录下所有文章名，根据文章名获取每篇文章的 =title= =digest= =date= =category= =post-url= =category-url= 信息，使用我自己写的 [[https://blog.geekinney.com/post/parse-elisp-list-to-html.html][print-html]] 函数生成上面的html，并把相关变量插入html中。最后输出到 =index.org= 的html导出模块中。代码如下：

#+BEGIN_SRC emacs-lisp
(require 'print-html)

(defvar blog-root-dir "~/iCloud/blog_site/")
(defvar blog-post-dir "~/iCloud/blog_site/org/")
(defvar blog-html-dir "~/iCloud/blog_site/post/")
(defvar blog-page-dir "~/iCloud/blog_site/page/")
(defvar blog-site-domain "https://blog.geekinney.com/")

(defun list-car-string-less (list1 list2)
  "compare the car of list1 to list2, which is a string"
  (if (string< (car list1) (car list2))
      (eq t t)
    (eq t nil)))

(defun my/blog-posts-sorted-by-date ()
  "make all posts name a list by date"
  (interactive)
  (let ((post-files (cdr (cdr (directory-files blog-post-dir))))
	(date-post-list '())
	(post-list '()))
    (mapcar (lambda (post)
	      (with-temp-buffer
		(insert-file-contents (concat blog-post-dir post))
		(goto-char (point-min))
		(re-search-forward "^#\\+DATE")
		(setq date (plist-get (cadr (org-element-at-point)) :value))
		(setq date-post-pair (list date post))
		(setq date-post-list (cons date-post-pair date-post-list))
		(erase-buffer)
		))
	    post-files)
    (setq date-post-list-sorted (sort date-post-list 'list-car-string-less))
    (mapcar (lambda (e)
	      (setq post-list (cons (cadr e) post-list)))
	    date-post-list-sorted)
    post-list))

(defun my/blog-generate-digest-html (posts)
  "generate blog's digest page html"
  (let ((html-str "")
	(category-url (concat blog-site-domain "category.html")))
    (mapcar (lambda (post)
	      (with-temp-buffer
		(setq post-url (concat blog-site-domain (string-trim blog-html-dir blog-root-dir) (car (split-string post "\\.")) ".html"))
		(setq valine-visitor-url (concat (string-trim blog-html-dir blog-root-dir) (car (split-string post "\\.")) ".html"))
		(insert-file-contents (concat blog-post-dir post))
		(setq count (my/word-count))
		(goto-char (point-min))
		(re-search-forward "^#\\+TITLE")
		(setq title (plist-get (cadr (org-element-at-point)) :value))
		(goto-char (point-min))
		(re-search-forward "^#\\+DATE")
		(setq date (plist-get (cadr (org-element-at-point)) :value))
		(goto-char (point-min))
		(re-search-forward "^#\\+CATEGORY")
		(setq category (plist-get (cadr (org-element-at-point)) :value))
		(setq buffer-string (replace-regexp-in-string "^#\\+.+\n+" "" (buffer-substring-no-properties (point-min) (point-max)))
		      buffer-string (replace-regexp-in-string "\\([a-zA-Z0-9]\\)[ ]+\\(\\cc\\)" "" buffer-string)
		      buffer-string (replace-regexp-in-string "\\[\\[.+\\]\\[" "" buffer-string)
		      buffer-string (replace-regexp-in-string "\\]\\]" "" buffer-string)
		      buffer-string (replace-regexp-in-string "\\*+" "" buffer-string)
		      buffer-string (replace-regexp-in-string "|-*" "" buffer-string)
		      buffer-string (replace-regexp-in-string "\n+" "" buffer-string)
		      buffer-string (replace-regexp-in-string " =" "" buffer-string)
		      buffer-string (replace-regexp-in-string "= " "" buffer-string))
		(setq digest (substring buffer-string 0 155))
		(erase-buffer)
		(insert
		 (print-html t `(div :class "post-div"
				     (h1 (a :href ,post-url ,title))
				     (p ,digest " ......" (a :href ,post-url "「阅读全文」"))
				     (code (a :href ,category-url ,category))
				     (span :class "post-date" ,date))))
		(setq html-str (concat html-str (buffer-substring-no-properties (point-min) (point-max))))
		))
	    posts)
    html-str))

(defun my/blog-generate-index-org (&optional proj)
  "generate blog index.org file"
  (interactive)
  (let* ((html-str (my/blog-generate-digest-html (my/blog-posts-sorted-by-date)))
	 (index-str (concat "#+TITLE: Geekinney Blog\n#+OPTIONS: title:nil\n#+begin_export html\n" html-str "#+end_export")))
    (with-temp-buffer
      (insert index-str)
      (write-file (concat blog-page-dir "index.org")))))
#+END_SRC

=my/blog-posts-sorted-by-date= 函数按照日期获取 =blog-post-dir= 下的所有org文章名称，结果返回一个列表。 =my/blog-generate-digest-html= 函数将文章列表作为参数，返回生成页面的所有html。 =my/blog-generate-index-org= 将生成的html写入 =index.org= 的html导出模块内。

最后，将 =my/blog-generate-index-org= 函数设为 =org-publish-project-alist= 变量的 =:preparation-function= 选项的值，这样每次在项目发布前会自动执行生成index页面的函数。然后在发布时导出为index.html。
</description>
<author>Kinney Zhang</author>
<pubDate>2020-02-22</pubDate>
</item>
<item>
<title>自动生成org blog辅助信息</title>
<link>https://blog.geekinney.com/post/auto-generate-blog-relative-info.html</link>
<description>#+TITLE: 自动生成org blog辅助信息
#+DATE: 2020-02-21
#+CATEGORY: 博客
#+MACRO: wc (eval (my/word-count))
#+INCLUDE: "../code/post-info.org"
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+TOC: headlines:2

一篇博客文章除了标题、正文，还有一些辅助的信息，比如：日期，分类，字数等。使用orgmode生成html不会自动生成这些内容，于是想hack一下。折腾效果如博文开头的：[ 分类: {{{keyword(category)}}} / 日期: {{{date}}} / 字数: {{{wc}}} ]。

这里主要使用了orgMode的 [[https://orgmode.org/manual/Macro-Replacement.html][Macro Replacement]] 功能。我们可以在org文件开头定义宏，然后在正文需要的位置调用宏就可以实现辅助信息的插入。

例如，定义如下宏：

#+begin_example
#+MACRO: poem Rose is $1, violet's $2. Life's ordered: Org assists you.
#+end_example

其中，"poem"为宏的名称，后面的内容为宏的内容，"$1，$2"为参数。然后在合适的位置调用宏：

#+begin_example
{{{poem(red,blue)}}}
#+end_example

最终的结果是在调用宏的位置插入"Rose is red, violet's blue. Life's ordered: Org assists you."。相信这种功能也不难理解，类似于函数的定义与调用。

除了插入一串字符，预先在org文件开头定义的一些keyword可以直接调用。也可以在宏中调用elisp函数，实现更为复杂的功能。blog辅助信息的生成就依赖这两个功能。为了实现上面的效果，我在文章开头插入了如下的宏调用：

<<macro-replace>>
#+begin_example
#+begin_center
[ 分类: {{{keyword(category)}}} / 日期: {{{date}}} / 字数: {{{wc}}} ]
#+end_center
#+end_example

其中 ={{{date}}}= 直接调用了 =#+DATE:= 预定义的日期， ={{{keyword(category)}}}= 调用了 =#+CATEGORY:= 预定义的分类。这里要说明的是，对于orgmode已有的keyword，如"TITLE, AUTHOR, DATE"这些可以直接调用。自定义的keyword如"CATEGORY"需要定义为形如 ={{{keyword(category)}}}= 的格式。最后，文章的字数需要使用一个elisp函数统计，这里需要定义一个统计字数的宏：

#+begin_example
#+MACRO: wc (eval (my/word-count))
#+end_example

不难理解，这个宏执行了 =my/word-count= 这个函数，然后插入到“字数：”后面。这个统计字数的函数定义如下：

#+BEGIN_SRC emacs-lisp
;; count words
(defvar wc-regexp-chinese-char-and-punc
  (rx (category chinese)))
(defvar wc-regexp-chinese-punc
  "[。，！？；：「」『』（）、【】《》〈〉※—]")
(defvar wc-regexp-english-word
  "[a-zA-Z0-9-]+")

(defun my/word-count ()
  "「較精確地」統計中/日/英文字數。
- 文章中的註解不算在字數內。
- 平假名與片假名亦包含在「中日文字數」內，每個平/片假名都算單獨一個字（但片假
  名不含連音「ー」）。
- 英文只計算「單字數」，不含標點。
- 韓文不包含在內。

※計算標準太多種了，例如英文標點是否算入、以及可能有不太常用的標點符號沒算入等
。且中日文標點的計算標準要看 Emacs 如何定義特殊標點符號如ヴァランタン・アルカン
中間的點也被 Emacs 算為一個字而不是標點符號。"
  (interactive)
  (let* ((v-buffer-string
          (progn
            (if (eq major-mode 'org-mode) ; 去掉 org 文件的 OPTIONS（以#+開頭）
                (setq v-buffer-string (replace-regexp-in-string "^#\\+.+" ""
								(buffer-substring-no-properties (point-min) (point-max))))
              (setq v-buffer-string (buffer-substring-no-properties (point-min) (point-max))))
            (replace-regexp-in-string (format "^ *%s *.+" comment-start) "" v-buffer-string)))
                                        ; 把註解行刪掉（不把註解算進字數）。
         (chinese-char-and-punc 0)
         (chinese-punc 0)
         (english-word 0)
         (chinese-char 0))
    (with-temp-buffer
      (insert v-buffer-string)
      (goto-char (point-min))
      ;; 中文（含標點、片假名）
      (while (re-search-forward wc-regexp-chinese-char-and-punc nil :no-error)
        (setq chinese-char-and-punc (1+ chinese-char-and-punc)))
      ;; 中文標點符號
      (goto-char (point-min))
      (while (re-search-forward wc-regexp-chinese-punc nil :no-error)
        (setq chinese-punc (1+ chinese-punc)))
      ;; 英文字數（不含標點）
      (goto-char (point-min))
      (while (re-search-forward wc-regexp-english-word nil :no-error)
        (setq english-word (1+ english-word))))
    (setq chinese-char (- chinese-char-and-punc chinese-punc))
    ;;  (message
    ;;      (format "中日文字數（不含標點）：%s
    ;; 中日文字數（包含標點）：%s
    ;; 英文字數（不含標點）：%s
    ;; =======================
    ;; 中英文合計（不含標點）：%s"
    ;;              chinese-char chinese-char-and-punc english-word
    ;;              (+ chinese-char english-word)))
    (+ chinese-char english-word)))
#+END_SRC

OK，这样每次在org发布项目的时候就会自动添加日期、分类和统计字数了。但是，每次在写blog的时候都要在开头加上[[macro-replace][这一段内容]]实在是麻烦。可以将这些内容放在单独的文件中，然后用 =#+INCLUDE:= 引入。

我将它们放在 =post-info.org= 这个文件中，完整的内容是：

#+begin_example
#+MACRO: wc (eval (my/word-count))
#+begin_center
[ 分类: {{{keyword(category)}}} / 日期: {{{date}}} / 字数: {{{wc}}} ]
#+end_center
#+end_example

然后在文章开头加上 =#+INCLUDE: "../code/post-info.org"= 即可。

注意：如果宏定义中执行的函数需要参数，一定要注意参数必须是字符串类型。比如参数中传入一个list，这个list就变成了字符串。在函数执行前需要先 =(read <list>)= 将字符串转为列表。
</description>
<author>Kinney Zhang</author>
<pubDate>2020-02-21</pubDate>
</item>
<item>
<title>视频压缩及格式(gif)转换</title>
<link>https://blog.geekinney.com/post/elisp-hack-compress-and-convert-video.html</link>
<description>#+TITLE: 视频压缩及格式(gif)转换
#+DATE: 2020-02-20
#+CATEGORY: Emacs
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+INCLUDE: "../code/post-info.org"

MacOS系统使用mov作为默认视频格式，mov格式的缺点是文件体积大，不便传输与使用。大多数时候我需要将视频压缩为mp4格式。同时，写文档时经常需要使用gif图片展示hack效果，所以将视频转为gif也成了硬需求之一。关于视频的压缩与格式转换，有很多在线工具以及app可以实现，但我更钟爱命令行工具。因为命令行比封装好的ui使用方便，可选参数多。最重要的是，可以和emacs结合。

[[https://www.ffmpeg.org/ffmpeg.html][ffmpeg]] 是一个非常优秀的视频处理命令，MacOS下可使用homebrew安装。做了下小hack，以后就可以在emacs中处理视频文件，生成gif啦。

#+BEGIN_SRC emacs-lisp
(defun my/video-compress-and-convert (video new)
  (interactive "fvideo path: \nfnew item name (eg. exam.mp4, exam.gif) : ")
  (let ((extension (cadr (split-string (file-name-nondirectory new) "\\."))))
    (if (string= extension "gif")
	(progn
	  (shell-command
	   (concat "ffmpeg -i " video " -r 5 " new))
	  (message "%s convert to %s successfully!" video new))
      (progn
	(shell-command
	 (concat "ffmpeg -i " video " -vcodec libx264 -b:v 5000k -minrate 5000k -maxrate 5000k -bufsize 4200k -preset fast -crf 20 -y -acodec libmp3lame -ab 128k " new))
	(message "%s compress and convert to %s successfully!" video new))
      )
    ))
#+END_SRC

除此之外， =ffmpeg= 的功能远不止这些，还支持视频的录制、剪辑合并、加滤镜和音频处理等，读者可以访问 [[https://www.ffmpeg.org][ffmpeg官网]] 探索。
</description>
<author>Kinney Zhang</author>
<pubDate>2020-02-20</pubDate>
</item>
<item>
<title>博客亮/暗色主题切换</title>
<link>https://blog.geekinney.com/post/blog-light-and-dark-theme-switch.html</link>
<description>#+TITLE: 博客亮/暗色主题切换
#+DATE: 2020-02-19
#+CATEGORY: 博客
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+INCLUDE: ../code/post-info.org
#+TOC: headlines:2

我的博客为亮色主题，晚间浏览时光线太强，于是想实现在亮色与暗色主题间的自由切换。实现原理参考了 https://gongzhitaao.org/orgcss/ ，即通过改变引入的css文件来实现主题切换。话不多说，先看看效果：

[[../static/img/blog-theme-switch.gif]]

下面是具体的实现步骤：

 1.在适当位置引入切换按钮。每次点击时触发 =switchTheme= 函数，实现主题切换。

    #+BEGIN_SRC html
    <span onclick="switchTheme();">切换主题</span>
    #+END_SRC

 2.在 =head= 标签间引入博客主题的css文件，我的默认为 =light.css= 。

    #+BEGIN_SRC html
    <link id="pagestyle" rel="stylesheet" type="text/css" href="/static/light.css"/>
    #+END_SRC

 3.在 =</body>= 标签之前引入 =switchTheme= 函数，通过改变css文件切换主题。实现单个按钮循环切换主题需要设置 =flag= 标志，标志状态存储在sessionStorage中。

    #+BEGIN_SRC js
    function switchTheme(){
	if(sessionStorage.getItem("flag")=="false"){
	    document.getElementById("pagestyle").href="/static/light.css";
	    sessionStorage.setItem("flag", "true");
	}else{
	    document.getElementById("pagestyle").href="/static/dark.css";
	    sessionStorage.setItem("flag", "false");
	}
    };
    #+END_SRC

 4.以上代码可以实现亮/暗两个主题的切换，但是有个问题：主题的状态不能保持，刷新页面就会使主题恢复到默认状态。我通过sessionStorage来存储主题状态，实现页面间共享。改写后完整的js如下：

    #+BEGIN_SRC js
    $(document).ready(function(){ //需要在head里引入jquery.
	var theme = sessionStorage.getItem("theme");
	if(theme=="dark"){
	    document.getElementById("pagestyle").href="/static/dark.css";
	}else if(theme=="light"){
	    document.getElementById("pagestyle").href="/static/light.css";
	}else{
	    sessionStorage.setItem("theme","light");
	}});

    function switchTheme(){
	if(sessionStorage.getItem("flag")=="false"){
	    document.getElementById("pagestyle").href="/static/light.css";
	    sessionStorage.setItem("theme","light");
	    sessionStorage.setItem("flag", "true");
	}else{
	    document.getElementById("pagestyle").href="/static/dark.css";
	    sessionStorage.setItem("theme","dark");
	    sessionStorage.setItem("flag", "false");
	}};
    #+END_SRC

Ok，这样就可以自由的切换博客主题，刷新也不会丢失状态啦～
</description>
<author>Kinney Zhang</author>
<pubDate>2020-02-19</pubDate>
</item>
<item>
<title>去你的2019，来我的2020</title>
<link>https://blog.geekinney.com/post/at-the-end-of-2019.html</link>
<description>#+TITLE:去你的2019，来我的2020
#+DATE: 2019-12-31
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+CATEGORY: 总结
#+INCLUDE: "../code/post-info.org"

2019接近尾声，这一年充满了选择与变化，虽然过程曲折但还算充实。我也慢慢的朝着自己想要的状态去走，有些慢，但没偏离轨迹。

回顾2019，顺利毕业，完整读了6本书，听了许多播客，搭建了自己的博客网站，尝试hack emacs，养成了一些好的习惯。最开心的是更加的了解自己，知道如何和自己相处。

2年前买的kindle，放在宿舍吃灰了很久，寒假心血来潮的重新拿起便[[https://blog.geekinney.com/post/pick-up-reading-after-read-the-moon-and-sixpence.html][重拾了阅读]]这件事情。

从[[https://book.douban.com/subject/26954760/][《月亮与六便士》]]开始，我开始认清一个道理：追随自己的内心，月亮或六便士，无论选择哪个，只要是心中所愿，便无谓对错。我想真正理解并且有勇气去践行这个道理，才算读懂了毛姆笔下的斯特里克兰，才算理解他那些”荒谬”的行为背后的逻辑。

[[Https://book.douban.com/subject/6781808/][《杀死一只知更鸟》]]，太爱这部小说了！无论是前半段斯库特和杰姆孩童生活的描写，还是后半段关于审判与正义的冲突，都相当的精彩。阿迪克斯的父亲形象也在家庭生活与坚持司法公正中得以刻画。

[[https://book.douban.com/subject/6016234/][《奇风岁月》]]涵盖的主题更多，涉及亲情、友情、死亡、写作、勇气、正义、悬疑、种族歧视....这样一本美国学生必读的经典就是一部生活的百科全书，每个人都能从中找到共鸣，其中有许多情节打动了我。

[[https://book.douban.com/subject/1046265/][《挪威的森林》]]自然不用多说，村上春树最畅销的小说，写少男少女的爱情。只是我没有太多的感触，可能是经历得不够。剩下两部是实用类的，《子弹笔记》和《如何有效阅读一本书》。目前在读 David Allen 的[[https://book.douban.com/subject/4849382/][《搞定I:无压生活的艺术》]]，也就是我们所熟知的GTD时间管理系统的原著，已读70%。[[https://book.douban.com/subject/2053249/][《麦田里的守望者》]]已读40%。

2019，听《大内密探》、《日谈公园》、《软件那些事儿》、《故事FM》、《黑水公园》、《文化土豆》、《晓说》等播客，让我看到了更广阔的世界和多样的人生。

2019，购买了VPS和域名，学着[[https://blog.geekinney.com/post/experience-of-setting-up-my-own-blog-site.html][搭建自己的博客网站]]，经历了从动态网站到静态网站，从markdown到org mode。博客的搭建和浏览别人的博客让我对计算机这个行业有了更深的认同感。

2019，继续折腾emacs，并且不满足于折腾。学习了elisp，从一些小函数开始，期待写一个自己的package。

2019，养成了两个好习惯，记账，写日记。记账用 [[https://github.com/ledger/ledger][ledger]] 这个命令行工具，对自己每一笔开销做到心中有数。写日记用emacs的 *org-journal* package，常记录常反思。更重要的是认识到，在GTD的系统中，一个习惯的养成并不困难。

2019，跑步断断续续，自己和自己较量也别有一番乐趣。最后认识到跑步机就能解决所有的问题。发际线变高，但问题不大。

2019，京东动画纵火事件，让不看动漫我，开始关注到这家动画公司。看了[[https://search.bilibili.com/all?keyword=凉宫春日][《凉宫春日的忧郁》]]、[[https://search.bilibili.com/all?keyword=轻音少女][《轻音少女》]]、[[https://search.bilibili.com/all?keyword=冰果][《冰果》]]等，这种从未有过的体验，给生活增添了许多的乐趣。凉宫中的神曲[[https://www.bilibili.com/video/av3108239?from=search&seid=11153679335489083516][《god knows》]]百听不厌，呆唯的形象在脑海中挥之不去。我也第一次的对声优这个行业有了一点了解。

2019，最最重要的是，更了解自己。懈怠的时候知道为什么会懈怠，积极的时候知道为什么会积极，状态不好时知道如何调整状态。不苛责自己，也不放纵自己。意识到，人一天的精力是有限的，精力不足的时候无需咬牙坚持，精力充沛的时候做最重要的事情。所谓的坚持，不是给自己打鸡血，不是赌咒发誓，而是和自己的身体与精神的博弈。生活中每一个悬而未决和待做的事情都会消耗精力，将这些事情交给一个可靠的系统，自己要做的就是按照逻辑来行动。

2019有一些不完美的地方，但也正是这些不完美，让我更加期待2020。

2020，计划读完《搞定》，然后hack org agenda 2.0，充分践行；学完驾照；跑步；学习专业上的内容；考研复习；hack emacs；多读几本书；每周总结，每月总结......

每个人的人生都有自己的节奏，有的人走的快，有的人走的慢；有的人年少功成，有的人厚积薄发。不用去比较，也无需理会世俗的观念，只要坚定和自信迈出的每一步就好！
</description>
<author>Kinney Zhang</author>
<pubDate>2019-12-31</pubDate>
</item>
<item>
<title>记我的博客折腾经历</title>
<link>https://blog.geekinney.com/post/experience-of-setting-up-my-own-blog-site.html</link>
<description>#+TITLE:记我的博客折腾经历
#+DATE: 2019-11-26
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+CATEGORY: 博客
#+INCLUDE: "../code/post-info.org"
#+TOC: headlines:2

我从2019年暑假初次学着搭建自己的blog网站。经历了从动态网站到静态网站，从markdown到org-mode。

第一版使用 *Django+mysql* 。自己从零开始查资料、写代码，最终折腾的像那么回事了。使用Django的优势很明显：动态网站拓展性高，后台管理系统，复习和学习了很多Django建站的知识。但缺点是需要和数据库打交道，并且在hack时经常会出现数据库迁移和服务器部署方面的问题。这可没少让我烦神。

第二版使用的是 *jekyll+github page* 。静态网站和动态网站比最大的优势就是不需要和数据库接触，只需维护每个markdown文档。Github page也免去了服务器部署的麻烦。Jekyll有丰富的主题可以选择，很轻松便可搭建漂亮的网站。但是没有让我满意的主题。之后又尝试了其他静态博客，如 *Hugo*, *Hexo* 等，同样是主题的问题。

第三版 *结合orgmode和静态blog* 。使用静态博客，意味着需要学习markdown，因为绝大多数的静态blog都只支持markdown渲染。Markdown自然很强大，但是作为emacser，我还是更喜欢[[https://orgmode.org/org.html][org mode]]。于是便折腾了[[https://blog.geekinney.com/post/using-org-to-blog-with-jekyll.html][使用org-mode撰写Jekyll blog]]。问题是，这种方法太不优雅！

第四版尝试 *完全基于org-mode* 的blog系统。melpa上有很多类似的package，比较著名的有org-page，org2web等。这些我都折腾了，不满意。原因要么是主题不好看，要么是流程太复杂。

经过了这四个阶段的折腾，我开始思考自己究竟需要什么样子的博客系统？结果总结为如下几点：
  * 白色系，主题简洁耐看。这是我不喜欢很多静态博客定制主题的原因。它们虽然一眼看上去都很漂亮，但是不耐看。我认为耐看的主题是简洁但功能强大的，给人一种“麻雀虽小，五脏俱全”的感觉。
  * 博客的受众主要是自己。除了一些技术文章，我的博客记录地更多是自己的思考与折腾经历。既然不为营销宣传，不为浏览量，自然也不需要做rss，SEO这些。
  * 不设评论系统。之前在评论系统的选择和搭建上我也花了不少精力，尝试过 Qisqus、Gitalks、Livere等。Disqus需要科学上网，Gitalks仅限Github账号登陆，Livere浏览器兼容做的不好。目前我还没有找到一款完美的评论系统。于是干脆放弃评论系统，有问题邮件联系。这样也避免了没有意义的评论。
  * 流程可控，可拓展。emacs是我最喜爱的生产力工具，将blog撰写和发布的所有流程放在emacs，我很放心。并且elisp的可拓展性是毋庸置疑的。

最终，我决定自己从零开始使用org-mode内置的功能搭建blog。静态博客网站的本质就是一个 =index.html= 加上一堆 =<blog_post_name>.html= 。如果想让网站漂亮一点，再加上一个 =style.css= 文件。至于其余的功能，如RSS，SEO，标签，评论等本质也就是对html进行一些添加、修改和处理。我暂时不需要这些功能，后面可根据需求添加。

OrgMode的 =org-publish= 原生支持批量org文件导出为HTML和添加导出样式，这使得基于org-mode搭建博客成为可能。最终的折腾效果见https://blog.geekinney.com。

更新：
 * 20191204:增加disqus评论系统，需要科学上网才能使用。
 * 20191215:增加google analysis，分析网站数据流量。
 * 20200103:实现对disqus的lazyload，提高网站访问速度。
 * 20200121:使用valine代替disqus，国内可访问。
 * 20200210:本地加载highlight.min.js和Valine.min.js并将js放在页面底部，大大提高网站访问速度。
 * 20200211:SEO优化，增加sitemap和robots.txt。
 * 20200213:增加博客暗色主题，使用localStorage存储状态，点击按钮切换主题。
 * 20200214:使用elisp自动生成博文开头辅助信息（日期，字数，分类）。
 * 20200219:使用elisp自动生成blog首页，显示摘要。
 * 20200224:将nav page页面与文章页面分开，nav page不设评论。
 * 20200228:修改博客整体样式。
 * 20200302:添加 =CC BY-NC-SA 4.0= 共享协议。
</description>
<author>Kinney Zhang</author>
<pubDate>2019-11-26</pubDate>
</item>
<item>
<title>elisp学习笔记</title>
<link>https://blog.geekinney.com/post/emacs-lisp-learning-note.html</link>
<description>#+TITLE: elisp学习笔记
#+DATE: 2019-11-12
#+STARTUP: content indent
#+OPTIONS: H:3 num:3 toc:nil
#+CATEGORY: Emacs
#+INCLUDE: "../code/post-info.org"
#+TOC: headlines:3

原文参考： [[http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html][Elisp Programming]]
* lisp介绍
Lisp（历史上拼写为LISP）是具有悠久历史的计算机编程语言家族，有独特和完全括号的前缀符号表示法。起源于公元1958年，是现今第二悠久而仍广泛使用的高端编程语言。只有FORTRAN编程语言比它更早一年。Lisp编程语族已经演变出许多种方言。现代最著名的通用编程语种是Clojure、Common Lisp和Scheme。

Lisp最初创建时受到阿隆佐·邱奇的lambda演算的影响，用来作为计算机程序实用的数学表达。因为是早期的高端编程语言之一，它很快成为人工智能研究中最受欢迎的编程语言。在计算机科学领域，Lisp开创了许多先驱概念，包括：树结构、自动存储器管理、动态类型、条件表达式、高端函数、递归、自主（self-hosting）编译器、读取﹣求值﹣输出循环（英语：Read-Eval-Print Loop，REPL）。

"LISP"名称源自“列表处理器”（英语：LISt Processor）的缩写。列表是Lisp的主要数据结构之一，Lisp编程代码也同样由列表组成。因此，Lisp程序可以把源代码当作数据结构进行操作，而使用其中的宏系统，开发人员可将自己定义的新语法或领域专用的语言，嵌入在Lisp编程中。

代码和数据的可互换性为Lisp提供了立即可识别的语法。所有的Lisp程序代码都写为S-表达式或以括号表示的列表。函数调用或语义形式也同样写成列表，首先是函数或操作符的名称，然后接着是一或多个参数：例如，取三个参数的函数f即为（f arg1 arg2 arg3）。

Lisp语言的主要现代版本包括Common Lisp, Scheme，Racket以及Clojure。1980年代盖伊·史提尔二世编写了Common Lisp试图进行标准化，这个标准被大多数解释器和编译器所接受。还有一种是编辑器Emacs所派生出来的Emacs Lisp（而Emacs正是用Lisp作为扩展语言进行功能扩展）非常流行，并创建了自己的标准。
* Elisp
** 概览
*** 运行emacs-lisp的几种方式
    | key        | command                | description                             |
    |------------+------------------------+-----------------------------------------|
    | =C-x C-e=  | =eval-last-sexp=       | 在S表达式结尾运行，在minibuffer显示结果 |
    | =C-j=      | =eval-print-last-sexp= | 在S表达式结尾运行，打印运行结果         |
    | =M-:=      | =eval-expression=      | 在minibuffer输入命令并执行              |
    | =M-x ielm= | =ielm=                 | 使用IELM解释器运行代码                  |

*** 创建命令（interactive函数）
    #+BEGIN_SRC emacs-lisp
    ;; example
    (defun buffer/insert-filename ()
      "Insert file path of current buffer at current point"
      (interactive)
      (insert (buffer-file-name (current-buffer))))
    #+END_SRC

*** emacs探索
    | key     | command             | description                                                                      |
    |---------+---------------------+----------------------------------------------------------------------------------|
    | =C-h k= | =describe-key=      | 运行命令后，继续按键，查看此时按键绑定的函数                                     |
    | =C-h b= | =describe-bindings= | 在*Help*界面搜索 =Major Mode Bindings:= 可以查看所有与当前major mode相关的按键。 |
    | =C-h f= | =describe-function= | 查看函数文档及详细代码                                                           |

** elisp编程的基本设置
   三个有用的pcakage:
   * rainbow-delimiters: 不同颜色区分不同层级的括号
   * paredit: 检查括号匹配
   * company: elisp代码补全

** 基本运算
*** 算术
    #+begin_example
    ELISP> (+ 20 30)
    50
    ELISP> (- 100 80)
    20
    ELISP> (+ 1 2 3 4 5 6)
    21
    ELISP> (* 1 2 3 4 5 6)
    720
    ELISP> (/ 1 100)
    0

    ELISP> (> 10 1) ;; ?? 10 > 1
    t
    ELISP> (< 2 8) ;; ?? 2 < 8
    t
    ELISP> (< 8 2) ;; ?? 8 < 2
    nil

    ELISP> (= 2 2)
    t
    ELISP> (= 2 4)
    nil

    ELISP> (/= 2 2)
    nil
    ELISP> (exp -1)
    0.36787944117144233
    ELISP> (log 10)
    2.302585092994046
    ELISP> (sin pi)
    1.2246467991473532e-16
    ELISP> (cos pi)
    -1.0
    ELISP> (tan (/ pi 2))
    1.633123935319537e+16
    ELISP>
    #+end_example

*** 比较
    #+begin_example
    ;;;; Compare Numbers
    ELISP> (= 2 (+ 1 1))
    t

    ;;; Compare Symbols and Numbers
    ELISP> (eq 1 1)
    t
    ELISP> (eq 1 2)
    nil
    ELISP>

    ELISP> (eq 'x 'x)
    t
    ELISP>

    ;;; Compare Elements of a List
    ELISP> (equal (list 1 2 3 4) (list 1 2 3 4))
    t

    ;;; Compare Strings
    ELISP> (string= "hello" "hello")
    t
    #+end_example

*** 列表
    #+begin_example
    ELISP> '(10 20 30 40)
    (10 20 30 40)

    ELISP> '(10 203 40 "hello" () ("empty" 65))
    (10 203 40 "hello" nil
	("empty" 65))
    #+end_example

** 类型判断和Literals
*** Emacs Literals
    #+begin_example
    ;;; Numbers
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ELISP> 1e3
    1000.0

    ;;; String
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ELISP> "Hello World Emacs Literals"
    "Hello World Emacs Literals"
    ELISP>

    ;;; Symbol
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ELISP> 'this-a-symbol
    this-a-symbol

    ELISP> 'vector->list
    vector->list

    ELISP> 'symbol?
    symbol\?
    ELISP>

    ;; Boolean t and nil
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ELISP> t
    t
    ELISP> nil
    nil
    ELISP>

     ;;; Everything that is not "nil" is true:
     ;;-----------------------------------------
    ELISP> (if t "It is true (not nil)" "It is false (it is nil)")
    "It is true (not nil)"
    ELISP>
    ELISP> (if 100e3 "It is true (not nil)" "It is false (it is nil)")
    "It is true (not nil)"
    ELISP> (if '(a b c d)  "It is true (not nil)" "It is false (it is nil)")
    "It is true (not nil)"
    ELISP>

    ELISP> (if nil  "It is true (not nil)" "It is false (it is nil)")
    "It is false (it is nil)"
    ELISP>

    ;;; Pair / Cons Cell
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ELISP> '(a . b)
    (a . b)

    ELISP> '(a . 2999)
    (a . 2999)

    ;;; List
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ELISP> '(1 2 3 (3 4) (5 6 (+ 3 4)) 10 'a 'b "hello" )
    (1 2 3
       (3 4)
       (5 6
	  (+ 3 4))
       10 'a 'b "hello")

    ELISP> '(+ 1 2 3 4 5)
    (+ 1 2 3 4 5)

    ELISP> '(cos 10)
    (cos 10)

    ;;; Vectors
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ELISP> [1 2 3 4 (+ 1 2 3 54)]
    [1 2 3 4
       (+ 1 2 3 54)]
    #+end_example

*** 基本类型判断
    | Type    | Predicate | Literal         | Description                                       |
    |---------+-----------+-----------------+---------------------------------------------------|
    | Nil     | null      | nil '()         | Test if argument is nil                           |
    | Numbers | numberp   | 100, 200e3      | Test if it is number.                             |
    | String  | stringp   | "hello"         | Test if it is string                              |
    | Symbol  | symbolp   | 'sym :keyworkd  | Test if it is a symbol.                           |
    |         |           |                 |                                                   |
    | Atom    | atom      | 'x "h" :key 200 | Everything that is not a list or pair is an atom. |
    | List    | listp     | '(1 2 x y)      | Test if it is a list                              |
    | Pair    | consp     | '(a . 200)      | Test if it is a pair (cons cell)                  |
    | Vector  | vectorp   | [1 200 'sym]    | Test if it is a vector                            |

    | Object  | Predicate |
    |---------+-----------|
    | Buffer  | bufferp   |
    | Window  | windowp   |
    | Frame   | framep    |
    | Process | processp  |

    #+begin_example
    ELISP> (null nil)
    t
    ELISP>
    ELISP> (null '())
    t

    ELISP> (null 10)
    nil

    ELISP> (atom 10)
    t
    ELISP> (atom '(a . b))
    nil
    ELISP> (atom "hello world")
    t
    ELISP>

    ELISP> (bufferp (current-buffer))
    t
    ELISP> (bufferp (selected-window))
    nil
    ELISP> (windowp (selected-window))
    t
    ELISP>
    #+end_example

*** 获取对象类型
    #+begin_example
    ELISP> (type-of (current-buffer))
    buffer
    ELISP>
    ELISP> (type-of (selected-window))
    window
    ELISP>

    ELISP> (equal 'buffer (type-of (current-buffer)))
    t
    ELISP> (equal 'buffer (type-of (selected-window)))
    nil
    ELISP>
    #+end_example
** 变量定义
   #+begin_example
   ;;; Constants
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ELISP> (defconst zsh-shell "/usr/bin/zsh")
   zsh-shell

   ELISP> zsh-shell
   "/usr/bin/zsh"
   ELISP>

   ;;; Define a variable
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ;;;; Set is not used very much
   ;;
   ELISP> (set 'avar "hello world")
   "hello world"

   ELISP> avar
   "hello world"
   ELISP>

   ;;;;; The most used command for assignment is setq
   ;;
   ELISP> (setq x 10)
   10

   ELISP> (setq avar "hello world")
   "hello world"

   ELISP> x
   10

   ELISP> avar
   "hello world"
   ELISP>

   ELISP> (setq my-list '(10 20 30 40))
   (10 20 30 40)

   ELISP> my-list
   (10 20 30 40)

   ;;; Multiple Assignment
   ;;
   ELISP> (setq a 10 b 20 c "Emacs")
   "Emacs"
   ELISP> a
   10
   ELISP> b
   20
   ELISP> c
   "Emacs"
   ELISP>

   ;; Dynamic Scoping  (Local Variables)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;
   ELISP> (let ((x 1) (y 10)) (+ (* 4 x) (* 5 y)) )
   54
   ELISP> x
       ** Eval error **  Symbol's value as variable is void: x
   ELISP> y
       ** Eval error **  Symbol's value as variable is void: y
   ELISP>
   #+end_example
** 函数定义
*** 定义简单函数
    语法: (defun <function name> (<parameters>) (<body>))
    #+begin_example
    ELISP> (defun afunction (a b c) (+ a b c))
    afunction

    ELISP> (afunction 10 20 30)
    60

    ELISP> (defun myfun () (message "Hello Emacs"))
    myfun
    ELISP> (myfun)
    "Hello Emacs"
    ELISP>


    ELISP>
    ELISP> (defun signum (n)
	 (cond ((> n 0) 1 )
	       ((< n 0) -1)
	       (0)))
    signum
    ELISP> (signum 10)
    1
    ELISP> (signum 0)
    0
    ELISP> (signum -23)
    -1
    ELISP>


    ELISP> (defun factorial (n)
	 (if (= n 0)
	     1
	     (* n (factorial (- n 1)))))
    factorial

    ELISP> (factorial 5)
    120
    ELISP
    #+end_example
*** 匿名函数/Lambda函数
    语法: (lambda (<parameters>) (<body>))
    #+begin_example
    ELISP> (lambda (x) (+ x 3))
    (lambda
      (x)
      (+ x 3))

    ;;; Applying Lambda Functions
    ;;

    ELISP> ((lambda (x) (+ x 3)) 4)
    7
    ELISP> (funcall (lambda (x) (+ x 3)) 4)
    7
    ELISP>

    ;;; Storing Lambda Function in Variable
    ;;
    ;;

    ELISP> (defvar add3 (lambda (x) (+ x 3)))
    add3


    ELISP> add3
    (lambda
      (x)
      (+ x 3))

    ELISP> (funcall add3 10)
    13

    ELISP> (add3 10)
	** Eval error **  Symbol's function definition is void: add3

    ELISP> (funcall #'add3 10)
	** Eval error **  Symbol's function definition is void: add3
    ELISP>

    ;;; Passing Lambda Function to functions
    ;;
    ELISP> (mapcar (lambda (x) (+ x 3))  '(1 2 3 4 5))
    (4 5 6 7 8)
    #+end_example
*** 函数作为参数
    语法: (caller-function #'<function-1> #'<function-1> arg1 arg2 ...)

    在函数内部，使用 =funcall= 调用函数作为参数

    #+begin_example
    ELISP> (mapcar log '(1 10 100 1000))
	** Eval error **  Symbol's value as variable is void: log


    ELISP> (mapcar #'log10 '(1 10 100 1000))
    (0.0 1.0 2.0 3.0)

    (defun sum-fun (f1 f2 x)
      (+ (funcall f1 x) (funcall f2 x)))

    ELISP> (sum-fun #'log #'exp 3)
    21.18414921185578
    ELISP>

    ELISP> (+ (log 3) (exp 3))
    21.18414921185578
    ELISP>

    ELISP> (sum-fun (lambda (x) (* 3 x))
	    (lambda (x) (* 4 x))
	    5)
    35
    ELISP>

    ELISP> (defun 1+ (x) (+ 1 x))
    1+
    ELISP> (defun 3* (x) (* 3 x))
    3*

    ELISP> (sum-fun #'1+  #'3* 4)
    17
    ELISP>

    ELISP> (sum-fun #'1+  (lambda (x) (* 3 x)) 4)
    17
    ELISP>
    #+end_example
*** 多参函数
    #+begin_example
    (defun sum (&rest numbers)
      (apply #'+ numbers))

    ELISP> (sum 1 2 3 4 5 6)
    21


    ELISP> (apply #'sum '(1 2 3 5 6))
    17

    ELISP> (apply #'sum (list 1 2 3 5 (+ 6 5 2)))
    24

    ELISP> (apply #'sum '())
    0

    ELISP> (apply #'sum nil)
    0

    ELISP> (sum nil)
	** Eval error **  Wrong type argument: number-or-marker-p, ni

    ;;----------------------------------

    (defun sum-prod (a &rest xs)
      (* a (apply #'+ xs)))


    ELISP> (sum-prod 3 1 2 3 4 5)
    45

    ELISP> (sum-prod 1 1 2 3 4 5)
    15
    #+end_example
*** 可选参数函数
    #+begin_example
    (defun test-optional (a &optional b)
      (list a b))

    ELISP> (test-optional 10 20)
    (10 20)

    ELISP> (test-optional 10 )
    (10 nil)

    ;--------------------------------;

    (defun test-optional2 (a b &optional b c d e)
      (list :a a :b b :c c :d d :e e))

    ELISP> (test-optional2 0 1 2 3 4 5 )
    (:a 0 :b 2 :c 3 :d 4 :e 5)


    ELISP> (test-optional2 0 1 2 3 4  )
    (:a 0 :b 2 :c 3 :d 4 :e nil)

    ELISP> (test-optional2 0 1 2 3   )
    (:a 0 :b 2 :c 3 :d nil :e nil)

    ELISP> (test-optional2 0 1 2    )
    (:a 0 :b 2 :c nil :d nil :e nil)

    ELISP> (test-optional2 0 1  )
    (:a 0 :b nil :c nil :d nil :e nil)

    ELISP> (test-optional2 0 1)
    (:a 0 :b nil :c nil :d nil :e nil)

    ;--------------------------------;

    (defun test-optional-default-b (a &optional b)
      (if b
	  (list a b)
	  (list a "b is null")))

    ELISP> (test-optional-default-b 1 2)
    (1 2)

    ELISP> (test-optional-default-b 1)
    (1 "b is null")

    ELISP> (test-optional-default-b 1 nil)
    (1 "b is null")
    #+end_example
*** 含属性列表参数函数
    #+begin_example
    (defun make-shell-interface (&rest params)
      "
      Create a shell interface.

      Possible parameters:

	:name      Name of shell
	:type      ['sh, 'bash, ...]
	:path      Path to program
	:buffer    Name of buffer

      "
      (let
	   ((name   (plist-get params :name ))
	    (type   (plist-get params :type))
	    (path   (plist-get params :path))
	    (buffer (plist-get params :buffer)))
	(list
	 (cons 'name buffer)
	 (cons 'type type)
	 (cons 'path path)
	 (cons 'buffer buffer))))


    ELISP> (make-shell-interface :name "pylaucher" :path "/usr/bin/python" :type 'sh :buffer "pyshell")
    ((name . "pyshell")
     (type . sh)
     (path . "/usr/bin/python")
     (buffer . "pyshell"))

    ELISP> (make-shell-interface :name "pylaucher" :path "/usr/bin/python" :type 'sh)
    ((name)
     (type . sh)
     (path . "/usr/bin/python")
     (buffer))

    ELISP> (make-shell-interface :name "pylaucher" :path "/usr/bin/python" :type 'bash)
    ((name)
     (type . bash)
     (path . "/usr/bin/python")
     (buffer))

    ELISP> (make-shell-interface :name "pylaucher" :path "/usr/bin/python")
    ((name)
     (type)
     (path . "/usr/bin/python")
     (buffer))

    ELISP> (make-shell-interface :name "pylaucher" )
    ((name)
     (type)
     (path)
     (buffer))

    ELISP> (make-shell-interface  )
    ((name)
     (type)
     (path)
     (buffer))

    ELISP> (make-shell-interface :buffer "pyshell"  :path "/usr/bin/python" :type 'sh :name "pylaucher")
    ((name . "pyshell")
     (type . sh)
     (path . "/usr/bin/python")
     (buffer . "pyshell"))
    #+end_example
*** Closures
    elisp方言默认不支持closure，所以下面的代码不会像Scheme或Common Lisp一样执行。

    参考：
    - [[https://www.emacswiki.org/emacs/LexicalBinding][EmacsWiki: Lexical Binding]]
    - [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][EmacsWiki: Dynamic Binding Vs Lexical Binding]]
    - [[https://nullprogram.com/blog/2013/12/30/][Emacs Lisp Readable Closures « null program]]
    - [[https://www.jamesporter.me/2013/06/14/emacs-lisp-closures-exposed.html][https://www.jamesporter.me/2013/06/14/emacs-lisp-closures-exposed.html]]
    - [[http://technical-dresese.blogspot.com/2011/04/brief-demonstration-of-emacs-new.html][Technical Dresese: A brief demonstration of emacs new lexical bindings]]

    #+begin_example
    (defun make-adder (x)
      (lambda (y) (+ x y)))


    ELISP>
    ELISP> (make-adder 3)
    (lambda
      (y)
      (+ x y))

    ELISP> ((make-adder 3) 4)
	** Eval error **  Invalid function: (make-adder 3)
    ELISP> (funcall (make-adder 3) 4)
	** Eval error **  Symbol's value as variable is void: x
    ELISP> (map (make-adder 3) '(1 2 3 4 5))
	** Eval error **  Symbol's value as variable is void: x
    ELISP>
    #+end_example

    支持closure的代码：
    #+begin_example
    (setq lexical-binding t)

    (defun make-adder (x)
      (lambda (y) (+ x y)))

    ELISP> (make-adder 3)
    (closure
     ((x . 3)
      t)
     (y)
     (+ x y))

    ELISP> ((make-adder 3) 4)
	** Eval error **  Invalid function: (make-adder 3)
    ELISP>

    ELISP> (funcall (make-adder 3) 4)
    7
    ELISP>

    ELISP> (mapcar (make-adder 3) '(1 2 3 4 5))
    (4 5 6 7 8)


    ;;;; Sometimes is better to create macro rather than a higher order function


    (defmacro make-sum-fun (f1 f2)
      `(lambda (x) (+ (,f1 x) (,f2 x))))

    ELISP>
    ELISP> (funcall (make-sum-fun sin cos) 3)
    -0.8488724885405782
    ELISP>
    ELISP> (make-sum-fun sin cos)
    (closure
     (t)
     (x)
     (+
      (sin x)
      (cos x)))

    ELISP> (map (make-sum-fun sin cos) '(1 2 3 4 5))
    (1.3817732906760363 0.4931505902785393 -0.8488724885405782 -1.4104461161715403 -0.6752620891999122)
    #+end_example

    在 =~/.emacs.d/init.el= 中添加如下配置以支持closure.
    #+begin_example
    (setq lexical-binding t)
    #+end_example
** 列表操作
   参考：
   - https://www.fincher.org/tips/Languages/Emacs.shtml

   #+begin_example
   ;; Defining a List
   ;;
   ;; An emacs list can contain elements of almost any type.
   ;;
   ELISP> '( "a" 2323 "b" 21.2323 "hello" "emacs" nil () (34 134) '(+ 2 3 5))
   ("a" 2323 "b" 21.2323 "hello" "emacs" nil nil
    (34 134)
    '(+ 2 3 5))

   ELISP> (quote (1 3 3 4 5))
   (1 3 3 4 5)

   ;;;;; Empty List
   ;;
   ELISP> nil
   nil
   ELISP> '()
   nil
   ELISP>

   ;; Length of a list
   ELISP> (length '(1 2 3 4 5 6))
   6
   ELISP>


   ;; nth element of a list
   ;;
   ELISP> (nth 0 '(0 1 2 3 4 5))
   0
   ELISP> (nth 2 '(0 1 2 3 4 5))
   2
   ELISP> (nth 5 '(0 1 2 3 4 5))
   5
   ELISP> (nth 10 '(0 1 2 3 4 5))
   nil
   ELISP>


   ;; Membership test
   ;; member returns null if the element is not member of the list
   ;;
   ELISP> (member 2 '(0 1 2 3 4 5))
   (2 3 4 5)

   ELISP> (member 10 '(0 1 2 3 4 5))
   nil
   ELISP>

   ;; Position of list element (prior to emacs 24.4)
   ;;
   ELISP> (position 7 '(5 6 7 8))
   2

   ELISP> (position 17 '(5 6 7 8))
   nil
   ELISP>

   ;; Position of list element (emacs 24.4 or later)
   ;;
   ELISP> (cl-position 7 '(5 6 7 8))
   2

   ELISP> (cl-position 17 '(5 6 7 8))
   nil
   ELISP>

   ;; cdr
   ;;
   ;; Removes first element of the list, returns the list tail.
   ;;
   ELISP> (cdr '(1 2 3 4 5))
   (2 3 4 5)

   ;; car
   ;;
   ;; Returns the first list element
   ;;
   ELISP> (car '(1 2 3 4 5))
   1
   ELISP>


   ;; cons
   ;;
   ;; List constructor
   ;;
   ELISP> (cons 10 '(1 2 3 4))
   (10 1 2 3 4)

   ELISP> (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 '())))))
   (1 2 3 4 5)

   ;; Last element of a list
   ;;
   ;;
   ELISP> (car (last '(1 2 3 4 5)))
   5
   ELISP>


   ;; Reverse a list
   ;;
   ELISP> (reverse '(1 2 3 4 5))
   (5 4 3 2 1)


   ;; Append lists
   ;;
   ;; Note: nil also means an empty list
   ;;
   ELISP> (append '(1 2) '( "a" "b" "c" "d"))
   (1 2 "a" "b" "c" "d")

   ELISP> (append '(1 2) nil '( "a" "b" "c" "d") nil)
   (1 2 "a" "b" "c" "d")



   ;; Filter list elements given a predicate function
   ;;
   ;;
   ELISP> (remove-if-not (lambda (x) (> x 2)) '(1 2 3 4 5 6 7 8 9 10))
   (3 4 5 6 7 8 9 10)

   ;; Test if list is empty
   ;;
   ELISP> (null '(1 2 3 4 5))
   nil
   ELISP> (null '())
   t
   ELISP> (null nil)
   t
   ELISP>

   ;; Drop the firsts n elements of a list
   ;;
   ;;
   ELISP> (nthcdr 2 '(1 2 3 4))
   (3 4)

   ELISP> (nthcdr 3 '(1 2 3 4))
   (4)

   ELISP> (nthcdr 13 '(1 2 3 4))
   nil
   ELISP>

   ;; Delete an element of a list
   ;;
   ;;
   ELISP> (delq 1 '(1 2 3 4))
   (2 3 4)


   ELISP> (delq 10 '(1 2 3 4))
   (1 2 3 4)

   ;; It doesn't work to delete sublists
   ;;
   ELISP> (delq (5) '(1 2 (5) 3 4))
       ** Eval error **  Invalid function: 5
   ELISP> (delq '(5) '(1 2 (5) 3 4))
   (1 2
      (5)
      3 4)

   ELISP> (delete '(5) '(1 2 (5) 3 4))
   (1 2 3 4)

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ;; Convert Vector to List
   ;;
   ;;
   ELISP> (coerce [1 2 3] 'list)
   (1 2 3)

   ;; Convert List to Vector
   ;;
   ELISP> (coerce '(1 2 3) 'vector)
   [1 2 3]

   ELISP> (number-sequence 0 10 2)
   (0 2 4 6 8 10)

   ELISP> (number-sequence 9 4 -1)
   (9 8 7 6 5 4)


   ;; Modify list variables.
   ;;
   ELISP> alist
   (a b c d e)

   ELISP> (push 'f alist)
   (f a b c d e)

   ELISP> alist
   (f a b c d e)

   ELISP> (pop alist)
   f

   ELISP> alist
   (a b c d e)

   ELISP> (pop alist)
   a
   ELISP> alist
   (b c d e)

   ELISP>
   #+end_example
** 关联列表和属性列表
*** 概览
    关联列表是一系列cons对，这里我可以称作 =clist= 或者 由两个元素组成的列表的集合，可以称为 =alist=

    *关联列表类型：clist*

    键: a, x, 2 and 4 值: b, y, 3 and (1 2 3 4 5)
    #+begin_example
    ELISP> '((a . b) (x . y) (2 . 3) (4 . (1 2 3 4 5)))
    ((a . b)
     (x . y)
     (2 . 3)
     (4 1 2 3 4 5)

    ELISP> (cons 'a 'b)
    (a . b)

    ELISP> (cons 'a (cons 'b (cons 'c nil)))
    (a b c)
    #+end_example

    *关联列表类型：alist*
    #+begin_example
    ELISP> '((a  b) (x  y) (2  3) (4  (1 2 3 4 5)))
    ((a b)
     (x y)
     (2 3)
     (4
      (1 2 3 4 5)))

    ELISP> (list (list 'a 'b) (list 'x 'y) (list 2 3) (list 2 '(1 2 3 4 5)))
    ((a b)
     (x y)
     (2 3)
     (2
      (1 2 3 4 5)))
    #+end_example
    =alist= 不像 =clist= 有歧义。

    *属性列表：Plist*

    属性列表是连续的键值对集合，它的优势是括号少和可读性高。
    #+begin_example
    '(:key1 value1 :key2 value2 :key3 1002.23 :key4 (a b c d e))

    ELISP> '(:key1 value1 :key2 value2 :key3 1002.23 :key4 (a b c d e))
    (:key1 value1 :key2 value2 :key3 1002.23 :key4
	   (a b c d e))

    ;;; It is more useful in configuration files

    (
    :key1  value1
    :key2  value2
    :key3  value3
    :key4  (a b c d e )
    )
    #+end_example
*** 关联列表/Alist
    #+begin_example
    ELISP> (setq dict
    '((pine . cones)
     (oak . acorns)
     (maple . seeds)))
    ((pine . cones)
     (oak . acorns)
     (maple . seeds))

    ELISP> dict
    ((pine . cones)
     (oak . acorns)
     (maple . seeds))

    ;; Get a cell associated with a key
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ELISP>
    ELISP> (assoc 'oak dict)
    (oak . acorns)

    ELISP> (assoc 'wrong dict)
    nil

    ;; Get a Key
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ELISP> (car (assoc 'oak dict))
    oak
    ELISP> (cdr (assoc 'oak dict))
    acorns
    ELISP>


    ELISP> (car (assoc 'oak dict))
    oak
    ELISP>

    ;; Get all keys
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ELISP> (mapcar #'car dict)
    (pine oak maple)

    ;; Get all values
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ELISP> (mapcar #'cdr dict)
    (cones acorns seeds)
    #+end_example

    例：过滤多个键
    #+begin_example
    ELISP> (defvar language-list
      '(
       ("io" . ((:command . "io")
		 (:description . "Run IO Language script")))
	("lua" . ((:command . "lua")
		  (:description . "Run Lua script")))
	("groovy" . ((:command . "groovy")
		     (:description . "Run Groovy")))
	("scala" . ((:command . "scala")
		    (:cmdopt . "-Dfile.encoding=UTF-8")
		    (:description . "Run Scala file with scala command")))

	("haml" . ((:command . "haml")
		   (:exec    . "%c %o %s")
		   (:description . "Convert HAML to HTML")))
	("sass" . ((:command . "sass")
		   (:exec    . "%c %o --no-cac")))
     ))
    language-list


    ELISP> (assoc  "scala"  language-list )
    ("scala"
     (:command . "scala")
     (:cmdopt . "-Dfile.encoding=UTF-8")
     (:description . "Run Scala file with scala command"))

    ELISP> (assoc  "lua"  language-list )
    ("lua"
     (:command . "lua")
     (:description . "Run Lua script"))

    ELISP> (assoc  "wrong"  language-list )
    nil

    ELISP> (assoc ':command (assoc  "scala"  language-list ))
    (:command . "scala")

    ELISP> (cdr (assoc ':command (assoc  "scala"  language-list )))
    "scala"
    ELISP>

    ELISP> (assoc ':description (assoc  "scala"  language-list ))
    (:description . "Run Scala file with scala command")

    ELISP> (cdr (assoc ':description (assoc  "scala"  language-list )))
    "Run Scala file with scala command"
    ELISP>

    ELISP> (mapcar 'car language-list)
    ("io" "lua" "groovy" "scala" "haml" "sass")

    ELISP> (mapcar 'cdr language-list)
    (((:command . "io")
      (:description . "Run IO Language script"))
     ((:command . "lua")
      (:description . "Run Lua script"))
     ((:command . "groovy")
      (:description . "Run Groovy"))
     ((:command . "scala")
      (:cmdopt . "-Dfile.encoding=UTF-8")
      (:description . "Run Scala file with scala command"))
     ((:command . "haml")
      (:exec . "%c %o %s")
      (:description . "Convert HAML to HTML"))
     ((:command . "sass")
      (:exec . "%c %o --no-cac")))

    ELISP>

    ELISP> (mapcar (lambda (x) (
				 list
				 (car x)
				 (cdr x)
				 ))
				language-list)
    (("io"
      ((:command . "io")
       (:description . "Run IO Language script")))
     ("lua"
      ((:command . "lua")
       (:description . "Run Lua script")))
     ("groovy"
      ((:command . "groovy")
       (:description . "Run Groovy")))
     ("scala"
      ((:command . "scala")
       (:cmdopt . "-Dfile.encoding=UTF-8")
       (:description . "Run Scala file with scala command")))
     ("haml"
      ((:command . "haml")
       (:exec . "%c %o %s")
       (:description . "Convert HAML to HTML")))
     ("sass"
      ((:command . "sass")
       (:exec . "%c %o --no-cac"))))

    ELISP>

    ELISP> (mapcar (lambda (x) (
	 list
	 (car x)
	 (assoc ':command       (cdr x))
	 (assoc ':cmdopt        (cdr x))
	 (assoc ':description   (cdr x))
	 ))
	language-list)

    (("io"
      (:command . "io")
      nil
      (:description . "Run IO Language script"))
     ("lua"
      (:command . "lua")
      nil
      (:description . "Run Lua script"))
     ("groovy"
      (:command . "groovy")
      nil
      (:description . "Run Groovy"))
     ("scala"
      (:command . "scala")
      (:cmdopt . "-Dfile.encoding=UTF-8")
      (:description . "Run Scala file with scala command"))
     ("haml"
      (:command . "haml")
      nil
      (:description . "Convert HAML to HTML"))
     ("sass"
      (:command . "sass")
      nil nil))

    ELISP>


    ELISP> (mapcar (lambda (x) (
	     list
	     (car x)
	     (cdr (assoc ':command   (cdr x)))
	     (cdr (assoc ':cmdopt       (cdr x)))
	     (cdr (assoc ':description   (cdr x)))
	     ))

	    language-list)
    (("io" "io" nil "Run IO Language script")
     ("lua" "lua" nil "Run Lua script")
     ("groovy" "groovy" nil "Run Groovy")
     ("scala" "scala" "-Dfile.encoding=UTF-8" "Run Scala file with scala command")
     ("haml" "haml" nil "Convert HAML to HTML")
     ("sass" "sass" nil nil))

    ELISP>

    ELISP> (defun get-value (alist key) (cdr (assoc key alist)))
    get-value
    ELISP> (get-value language-list "scala")
    ((:command . "scala")
     (:cmdopt . "-Dfile.encoding=UTF-8")
     (:description . "Run Scala file with scala command"))

    ELISP> (get-value language-list "lua")
    ((:command . "lua")
     (:description . "Run Lua script"))

    ELISP>
    ELISP> (get-value language-list "0")
    nil
    ELISP>


    ELISP> (defun get-key-value (alist key field)
		    (cdr (assoc  field  (cdr (assoc key alist))  )))
    get-key-value
    ELISP>
    ELISP> (get-key-value language-list "scala" ':description)
    "Run Scala file with scala command"
    ELISP>

    ELISP> (get-key-value language-list "scala" ':command)
    "scala"
    ELISP>
    #+end_example
*** 属性列表
    #+begin_example
    ELISP> (defvar plst (list :buffer (current-buffer) :line 10 :pos 2000))
    plst

    ELISP>
    ELISP> (plist-get plst :line)
    10

    ELISP> (plist-get plst :pos)
    2000

    ELISP> (plist-get plst :buffer)
    #<buffer *ielm*>
    ELISP>

    ELISP>
    ELISP> (plist-get plst :buffdfds)
    nil
    ELISP>

    ELISP> (plist-member plst :buffer)
    (:buffer #<buffer *ielm*> :line 10 :pos 2000)

    ELISP> (plist-member plst :bufferasd)
    nil
    ELISP>

    ELISP> (plist-put plst :winconf (current-window-configuration))
    (:buffer #<buffer *ielm*> :line 10 :pos 2000 :winconf #<window-configuration>)

    ELISP> plst
    (:buffer #<buffer *ielm*> :line 10 :pos 2000 :winconf #<window-configuration>)

    ELISP>
    #+end_example
*** 转换Alist成Plist和vice-versa
    #+begin_example
    ;; Alist to plist
    (defun plist->alist (plist)
      (if (null plist)
	  '()
	  (cons
	   (list (car plist) (cadr plist))
	   (plist->alist (cddr plist)))))

    ELISP> (plist->alist (list :x 10 :y 20 :name "point"))
    ((:x 10)
     (:y 20)
     (:name "point"))

    ;;; Converts association list to plist
    (defun alist->plist (assocl)
      (if (null assocl)
	  '()
	(let
	((hd (car assocl))
	 (tl (cdr assocl)))
	  (cons (car hd)
	    (cons (cadr hd)
	      (alist->plist tl))))))

    ;;; Converts plist to clist (List of cons pairs)
    (defun plist->clist (plist)
      (if (null plist)
	  '()
	  (cons
	   (cons (car plist) (cadr plist))
	  (plist->clist (cddr plist)))))

    ELISP> (plist->clist (list :x 10 :y 20 :name "point"))
    ((:x . 10)
     (:y . 20)
     (:name . "point"))

    ;; Separates a property list into two lists of keys and values.
    ;;
    (defun plist->kv (plist)
      (let ((alist (plist->alist plist)))
	(cons
	 (mapcar #'car alist)
	 (mapcar #'cdr alist))))

    ELISP> (setq al (plist->alist (list :x 10 :y 20 :name "point")))
    ((:x 10)
     (:y 20)
     (:name "point"))

    ELISP> (alist->plist al)
    (:x 10 :y 20 :name "point")

    ELISP>

    (setq keylist
	'("M-i"  'previous-line
	  "M-j"  'backward-char
	  "M-k"  'next-line
	  "M-l"  'forward-char))


    ELISP> (setq kv (plist->kv keylist))
    (("M-i" "M-j" "M-k" "M-l")
     ('previous-line)
     ('backward-char)
     ('next-line)
     ('forward-char))

    ELISP> (car kv)
    ("M-i" "M-j" "M-k" "M-l")

    ELISP> (cdr kv)
    (('previous-line)
     ('backward-char)
     ('next-line)
     ('forward-char))

    ELISP>
    #+end_example
** 字符串
   #+begin_example
   ;; Split String

   ELISP> (split-string "  two words ")
   ("two" "words")

   ELISP>

   ELISP> (split-string "o\no\no" "\n" t)
   ("o" "o" "o")

   ELISP> (split-string "Soup is good food" "o*" t)
   ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")

   ELISP>

   ;; Format String

   ELISP> (format-time-string "%Y/%m/%d %H:%M:%S" (current-time))
   "2015/06/26 06:10:04"
   ELISP>
   ELISP>


   ;; Concatenate Strings

   ELISP> (concat "The " "quick brown " "fox.")
   "The quick brown fox."
   ELISP>

   ELISP> (mapconcat 'identity '("aaa" "bbb" "ccc") ",")
   "aaa,bbb,ccc"
   ELISP> (split-string "aaa,bbb,ccc" ",")
   ELISP> (split-string "aaa,bbb,ccc" ",")
   ("aaa" "bbb" "ccc")

   ;; String Width

   ELISP> (string-width "hello world")
   11
   ELISP>
   ELISP> (substring "Freedom Land" 0 5)
   "Freed"
   ELISP>
   ELISP> (string-match "ce" "central park")
   0
   ELISP> (string-match "gt" "central park")
   nil
   ELISP>


   ;;;;; Misc

   ELISP> (make-string 5 ?x)
   "xxxxx"
   ELISP> (make-string 5 ?a)
   "aaaaa"
   ELISP> (make-string 5 ?r)
   "rrrrr"
   ELISP> (make-string 15 ?r)
   "rrrrrrrrrrrrrrr"
   ELISP>
   #+end_example

   *elisp符号/字符串转换*
   #+begin_example
   ; Convert a symbol to string
   ELISP> (symbol-name 'wombat)
   "wombat"

   ; Convert a String to Symbol
   ELISP> (intern "wombat")
   wombat
   #+end_example

   *读取字符串中的S表达式*
   #+begin_example
   ELISP> (read-from-string
	       "(
		  (POINT1  (X  10.2323)  (Y   20.2323))
		  (POINT2  (x  0.2)          (Y 923.23))
		  (POINT3  (x -10.5)       (Y 78,23))
		)")
   (((POINT1
      (X 10.2323)
      (Y 20.2323))
     (POINT2
      (x 0.2)
      (Y 923.23))
     (POINT3
      (x -10.5)
      (Y 78
	 (\, 23))))
    . 174)

   ELISP>
   #+end_example
** 符号
   #+begin_example
   ;;; Convert a string to symbol

   ELISP> (intern "a-symbol")
   a-synmbol
   ELISP> (symbolp (intern "a-symbol"))
   t
   ELISP>

   ;;; Convert a symbol to a string

   ELISP> (symbol-name 'symbol)
   "symbol"
   ELISP>

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ELISP> (setq sym '(1 2 3 4 5))
   (1 2 3 4 5)

   ELISP> sym
   (1 2 3 4 5)

   ;;; Test if variable is defined
   ELISP> (boundp 'sym)
   t
   ELISP>

   ;;; Test if variable sym is a symbol
   ELISP> (symbolp sym)
   nil

   ;;; Test if the symbol sym is a symbol
   ELISP> (symbolp 'sym)
   t
   ELISP>

   ;; Get symbol as string
   ;;
   ELISP> (symbol-name 'sym)
   "sym"

   ;; Get value from a symbol
   ;;
   ELISP> (symbol-value 'sym)
   (1 2 3 4 5)

   ELISP> (symbol-function 'sym)
   nil

   ELISP> (symbol-plist 'sym)
   nil

   ;;-------------------------;;

   ELISP> (defun func (x y) (+ (* 3 x) (* 4 y)))
   func

   ELISP> (func 10 2)
   38
   ELISP>

   ;;; Check if function is defined
   ;;
   ELISP> (fboundp 'func)
   t
   ELISP> (fboundp 'sym)
   nil
   ELISP>


   ELISP> (symbol-name 'func)
   "func"

   ELISP> (symbol-value 'func)
       ** Eval error **  Symbol's value as variable is void: func
   ELISP> (symbol-function 'func)
   (lambda
     (x y)
     (+
      (* 3 x)
      (* 4 y)))

   ELISP> (symbol-plist 'func)
   nil
   ELISP>

   ;;; Function Source Code

   ELISP> (symbol-function #'func)
   (lambda
     (x y)
     (+
      (* 3 x)
      (* 4 y)))


   ;; Test if function is an elisp primitive

   ELISP> (subrp (symbol-function 'goto-char))
   t
   ELISP>
   #+end_example
** 类型转换
   *类型查询*
   #+begin_example
   ELISP> (type-of 1000)
   integer

   ELISP> (type-of 1000.3434)
   float
   ELISP>

   ELISP> (type-of "lisp")
   string

   ELISP> (type-of '(1 2 3 4 5))
   cons
   ELISP> (type-of (list 'cos 'sin 1 2 3 4 5))
   cons
   ELISP>

   ELISP> (type-of [1 2 3 4])
   vector

   ELISP> (type-of 'elisp-mode-map)
   symbol
   ELISP>

   ELISP> (type-of #'cos)
   symbol
   ELISP>
   #+end_example

   *类型判断*
   #+begin_example
   ;; Test if it is a number
   ;;-----------------------------------

   ELISP> (numberp 1000)
   t
   ELISP> (numberp 10e4)
   t
   ELISP> (numberp '(1 2 3 4))
   nil
   ELISP> (numberp "hello world")
   nil
   ELISP>


   ;; Test if it is a string
   ;;-----------------------------------

   ELISP> (stringp "Emacs")
   t
   ELISP> (stringp '(1 2 3 4))
   nil
   ELISP>

   ;; Test if ti is a symbol
   ;;------------------------------------
   ELISP> (symbolp 'emacs)
   t
   ELISP> (symbolp #'emacs)
   t
   ELISP> (symbolp "something")
   nil
   ELISP> (symbolp 10000)
   nil
   ELISP>


   ;; Test if it is a list
   ;;-----------------------------------

   ELISP> (listp '(1 2 3 4))
   t
   ELISP> (listp [1 2 3 4])
   nil
   ELISP> (listp "hello world")
   nil
   ELISP>


   ;; Test if it is a vector
   ;;-----------------------------------

   ELISP> (vectorp ["Lisp" "Emacs" "Scheme" "Clojure"])
   t
   ELISP>
   ELISP> (vectorp '(1 2 3))
   nil
   ELISP> (vectorp "lisp")
   nil
   ELISP>
   #+end_example

   *数字/字符串转换*
   #+begin_example
   ELISP>
   ELISP> (number-to-string 1000)
   "1000"

   ELISP> (string-to-number "200")
   200
   ELISP>
   ELISP>
   #+end_example

   *符号/字符串转换*
   #+begin_example
   ELISP> (symbol-name 'my-symbol)
   "my-symbol"

   ELISP> (symbol-name :my-symbol)
   ":my-symbol"
   ELISP>

   ELISP> (intern "some-symbol")
   some-symbol
   #+end_example

   *S表达式/字符串转换*
   * read: 解析S表达式
   #+begin_example
   ELISP>
   ELISP> (setq raw "(:x 10 :y 20 :z 30 :w \"hello world\")")
   "(:x 10 :y 20 :z 30 :w \"hello world\")"
   ELISP>
   ELISP> (read raw)
   (:x 10 :y 20 :z 30 :w "hello world")

   ELISP> (plist-get (read raw) :x)
   10
   ELISP> (plist-get (read raw) :w)
   "hello world"
   ELISP>
   #+end_example 

   * prin1-to-string: 序列化S表达式
   #+begin_example
   ELISP> (setq sexp '(:x 10 :y 20 :z 30 :w "hello world"))
   (:x 10 :y 20 :z 30 :w "hello world")

   ELISP> sexp
   (:x 10 :y 20 :z 30 :w "hello world")

   ELISP> (prin1-to-string sexp)
   "(:x 10 :y 20 :z 30 :w \"hello world\")"
   ELISP>
   #+end_example
** 求值
   *S表达式求值*
   #+begin_example
   ELISP> (eval '(+ 1 2 3 4 5))
   15
   ELISP>


   ELISP> '(defun func1(x)(* 10 x))
   (defun func1
       (x)
     (* 10 x))

   ELISP>

   ELISP> '((+ 1 3) (* 4 5) (- 8 9))
   ((+ 1 3)
    (* 4 5)
    (- 8 9))

   ELISP> (eval '(defun func1(x)(* 10 x)))
   func1
   ELISP> (func1 5)
   50
   ELISP>


   ELISP> (mapcar 'eval '((+ 1 3) (* 4 5) (- 8 9)))
   (4 20 -1)
   #+end_example

   *字符串求值*
   #+begin_example
   ELISP> (defun eval-string (str) (eval (read str)))
   eval-string

   ELISP> (eval-string "(+ 1 2 3 4 5 6)")
   21
   ELISP>

   ELISP> (eval-string "(defun func2(x)(* 10 x)))")
   func2
   ELISP> (func2 6)
   60
   ELISP>
   #+end_example

   *S表达式格式化为字符串*
   #+begin_example
   ELISP> (setq sexp1 '(+ 1 (* 2 3)))
   (+ 1
      (* 2 3))

   ELISP> (eval sexp1)
   7

   ELISP> (format "%S" sexp1)
   "(+ 1 (* 2 3))"
   ELISP>
   #+end_example

   *Elisp中的求值命令*
   | 命令                | 功能               |
   |---------------------+--------------------|
   | M-x eval-defun      | 函数求值           |
   | M-x eval-region     | 区域内表达式求值   |
   | M-x eval-buffer     | buffer内表达式求值 |
   | M-x eval-expression | 输入框输入求值     |
   | M-x load-file       | 文件加载           |
** Defalias
   内置宏 =defalias= 可以为emaca函数定义简短的名字。

   参考：[[http://ergoemacs.org/emacs/emacs_alias.html][Emacs: Use Alias for Fast M-x]]

   #+begin_example
   ELISP> (require 'cl)
   cl
   ELISP>

   ELISP> (defalias 'map 'mapcar)
   map
   ELISP> (map (lambda (x) (* 3 x)) (list 1 2 3 4 5 6))
   (3 6 9 12 15 18)

   ELISP> (defalias 'filter 'remove-if-not) ;; remove-if-not comes from "cl" library
   filter

   ;;; Filter all buffers bounded to a file
   ;;
   ELISP> (filter #'buffer-file-name (buffer-list))
   (#<buffer README.org> #<buffer Projects.wiki.org> #<buffer Index.wiki.org> #<buffer settings.org> #<buffer project.org>)

   ;;; Reject all buffers which are not bounded to a file
   ELISP> (reject #'buffer-file-name (buffer-list))
   (#<buffer *ielm*> #<buffer *Help*> #<buffer  *Minibuf-1*> #<buffer emacs> #<buffer *scratch*> ..)

   ;;; The command M-x org-html-export-to-htm will export this document (README.org) to html
   ;;  the command M-x org2html will do so too.
   ;;
   (defalias #'org2html #'org-html-export-to-html)

   ;;
   ;;  It is also useful to create more convenient names for Emacs API
   ;; in a namsepace-like fashion that makes easier to find functions and
   ;; autocomplete functions, for instance:
   ;;
   (defalias 'file/extension         'file-name-extension)
   (defalias 'file/extension-sans    'file-name-sans-extension)
   (defalias 'file/path-expand       'expand-file-name)
   (defalias 'file/filename          'file-name-nondirectory)
   (defalias 'file/path-relative     'file-relative-name)
   (defalias 'file/rename            'rename-file)
   (defalias 'file/delete            'delete-file)
   (defalias 'file/copy              'copy-file)

   ;;; To find the documentation of a function group defined in this fashion
   ;; Enter M-x apropos  and then type file/
   (apropos "file/")

   ELISP> (set-buffer "README.org")
   #<buffer README.org>
   ELISP> (buffer-file-name)
   "/home/tux/PycharmProjects/emacs/README.org"
   ELISP> (file/basename (buffer-file-name))
   "README"
   ELISP> (file/extension (buffer-file-name))
   "org"
   ELISP> (file/filename (buffer-file-name))
   "README.org"
   ELISP>
   #+end_example
** 控制结构
*** Conditional Statement
    *If Else 语句*
    #+begin_example
    ;;
    ;; Any value different from nil or '() is true, otherwise false.
    ;;

    ;; True
    ;;
    ELISP> (if t 5 6)
    5

    ELISP> (if 10 5 6)
    5

    ELISP> (if 0 5 6)
    5

    ;; False
    ELISP> (if nil 5 6)
    6

    ELISP> (if '() 5 6)
    6


    ;; Inverting Predicate
    ;;
    ELISP> (if (not t) 5 6)
    6

    ELISP> (if (not nil) 5 6)
    5


    ELISP> (if (< 5 10)  (message "less than 10") (message "greater or equal to 10") )
    "less than 10"

    ELISP> (if (< 30 10)  (message "less than 10") (message "greater or equal to 10") )
    "greater or equal to 10"
    ELISP>

    ;;; If else with multiple statements

    ELISP> (setq x 10)
    10

    ELISP> (if (> x 5)
	   ;; Then Statement
	   (progn

	     (message "Positive Number")
	     (print "Greater than five")
	     (split-window-vertically)
	     78 ;;  Return Value
	    )
	 ;; Else Statement
	 (progn
	   (print "Less than five")
	   (split-window-horizontally)
	   12 ;;  Return Value
	 ))

    "Greater than five"

    78
    ELISP>
    #+end_example

    *When语句*
    #+begin_example
    ELISP> (when t 3)
    3

    ELISP> (when nil 3)
    nil


    ELISP> (setq x 5)
    5

    ELISP> (when (> x 3)
	     (message "Less than 3"))
    "Less than 3"
    ELISP>

    ELISP> (setq x 1)
    1

    ELISP> (when (> x 3)
	     (message "Less than 3"))
    nil
    ELISP>


    ;;;;; When with Multiple Statements

    ELISP> (setq x 10)
    10

    ELISP> (when (> x 7)
	 (progn
	   (message "Greater than 7 OK.")
	   (message "Print message 2")
	   (split-window-horizontally)
	  ))

     #<window 8 on *ielm*>
    ELISP>
    #+end_example
*** Cond - Case Switch
    #+begin_example
    ELISP> (setq a 3)       ;; a = 3
    3
    ELISP>

    ELISP> (cond
	    ((evenp a) a)       ;; if   (a % 2 == 0)    ==> a
	    ((> a 7) (/ a 2))   ;; elif (a > 7)         ==> a/2
	    ((< a 5) (- a 1))   ;; elif (a < 5)         ==> a-1
	    (t 7)               ;; else                 ==> 7
	    )
    2
    ELISP>
    #+end_example

*** CL-Case - Case Switch
    #+begin_example
    (defun test-cl-case (operation x y)
      (cl-case operation
	(:mul (* x y))
	(:add (+ x y))
	(:sub (- x y))
	(:div (/ x y))
	(otherwise nil)))

    ELISP> (test-cl-case :mul 2 10)
    20

    ELISP> (test-cl-case :sub 10 2)
    8

    ELISP> (test-cl-case :add 10 2)
    12
    ELISP> (test-cl-case :div 10 2)
    5

    ELISP> (test-cl-case 'dummy 20 10)
    nil
    #+end_example

*** 循环
    *Dolist*
    #+begin_example
    ELISP> (dolist (h '(a b c)) (print h))

    a

    b

    c

    nil

    ELISP> (dolist (x '(1 2 3)) (print (* 2 x)))

    2

    4

    6

    nil
    ELISP>

    ELISP> (dolist (x '(1 2 3))
	     (dolist (y '(a b))
		(print (list x y))))
    (1 a)

    (1 b)

    (2 a)

    (2 b)

    (3 a)

    (3 b)

    nil
    ELISP>
    #+end_example

    *Dotimes*
    #+begin_example
    ELISP> (dotimes (i 3) (print i))

    0

    1

    2

    nil
    ELISP

    ELISP> (dotimes (i 3) (print (* 2 i)))

    0

    2

    4

    nil
    ELISP>
    #+end_example

    *Loop*

    最好使用 =map= 和 =filter= 代替 =loops= , 详见 Functional Programming

    #+begin_example
    ELISP> (setq a 4)
    4

    ELISP> (loop
	    (setq a (+ a 1))
	    (when (> a 7) (return a)))
    8

    ELISP> a
    8
    ELISP>

    ELISP> (loop
       (setq a (- a 1))
       (when (< a 3) (return)))
    nil
    ELISP> a
    2
    ELISP>
    #+end_example

    *Loop Collecting / Summing / For*
    #+begin_example
    ELISP> (loop for i from 1 to 10 collecting i)
    (1 2 3 4 5 6 7 8 9 10)

    ELISP> (loop for i from 1 to 10 collecting (* 3 i))
    (3 6 9 12 15 18 21 24 27 30)

    ELISP> (loop for x from 1 to 10 summing (expt x 2))
    385

    ELISP> (loop for x from 1 to 10 collecting (* 2 x))
    (2 4 6 8 10 12 14 16 18 20)

    ELISP> (loop for x from 1 to 10 summing (* 2 x))
    110
    ELISP>

    ELISP> (apply #'+ '(2 4 6 8 10 12 14 16 18 20))
    110

    ELISP> (loop for i below 10 collecting i)
    (0 1 2 3 4 5 6 7 8 9)

    ELISP>  (loop for x in '(1 2 3)
	  do (print x) )

    1

    2

    3

    nil

    (loop
	   for x in '(a b c)
	   for y in '(1 2 3 4 5 6)
	   collect (list x y))
    ((a 1)
     (b 2)
     (c 3))

    ELISP> (loop for (a b) in '((x 1) (y 2) (z 3))
	  collect (list b a))
    ((1 x)
     (2 y)
     (3 z))

    ELISP> (loop for i upto 20
	  if (oddp i)
	    collect i into odds
	  else
	    collect i into evens
	  finally (return (values evens odds)))
    ((0 2 4 6 8 10 12 14 16 18 20)
     (1 3 5 7 9 11 13 15 17 19))
    #+end_example

    *Do Loop*
    #+begin_example
    (do (variable-definition*)
	(end-test-form result-form*)
      statement*)
    #+end_example

    #+begin_example
    (do
       ;; Variables Definitions
       ((i 0 (1+ i)))

       ;; Test form
	((>= i 4))

      ;; Statement form
      (print i))

    0

    1

    2

    3
    nil

    ;; Fibbonaci Computing Loop
    ;;
    (do ((n 0 (1+ n))
	 (cur 0 next)
	 (next 1 (+ cur next)))
	((= 10 n) cur))
    55
    #+end_example

*** 函数式编程
    [[https://github.com/magnars/dash.el.git][Dash]] 是emacs经常使用的函数式编程库。

    * Map and Filter

    *Mapcar / Equivalent to map*
    #+begin_example
    ELISP> (defun my-fun (x) (* x 10))
    my-fun
    ELISP>

    ELISP> (mapcar 'my-fun '(1 2 3 5 6))
    (10 20 30 50 60)

    ELISP> (mapcar 'capitalize '("hello" "world" "emacs"))
    ("Hello" "World" "Emacs")

    ;;  Anonymous Functions
    ;;
    ELISP> (mapcar (lambda (x) (* x x))   '(1 2 3 4 5 6))
    (1 4 9 16 25 36)


    ELISP> (setq anon (lambda (x) (* x x)))
    (lambda
      (x)
      (* x x))

    ELISP> (mapcar anon '(1 2 3 4 5 6))
    (1 4 9 16 25 36)
    #+end_example

    *Filter*
    #+begin_example
    ELISP> (null nil)
    t
    ELISP> (null 23)
    nil
    ELISP>

    ;; Equivalent to  Haskell idiom:
    ;;
    ;; > filter predicate list
    ;;
    ELISP> (remove-if-not 'null '(1 2 3 nil 5 6 nil nil ))
    (nil nil nil)

    ;; Equivalent to Haskell idiom:
    ;;
    ;;   > filter (\x -> not (predicate x)) list
    ;;
    ;; a more apropriate name would be reject
    ;;
    ELISP> (remove-if 'null '(1 2 3 nil 5 6 nil nil ))
    (1 2 3 5 6)



    ELISP> (defun range (step start stop)
      (if (> start stop)
	  nil
	  (cons start (range step (+ step start) stop))

      );; End If
    );; End range

    ELISP> (range 1 0 10)
    (0 1 2 3 4 5 6 7 8 9 10)

    ELISP> (range 2 0 20)
    (0 2 4 6 8 10 12 14 16 18 20)


    ELISP> (remove-if (lambda (x) (= (% x 2) 0)) (range 1 0 20))
    (1 3 5 7 9 11 13 15 17 19)

    ELISP> (remove-if-not (lambda (x) (= (% x 2) 0)) (range 1 0 20))
    (0 2 4 6 8 10 12 14 16 18 20)


    ELISP> (remove-if (lambda (x) (= (% x 3) 0)) (range 1 0 20))
    (1 2 4 5 7 8 10 11 13 14 16 17 19 20)

    ELISP> (remove-if-not (lambda (x) (= (% x 3) 0)) (range 1 0 20))
    (0 3 6 9 12 15 18)

    ELISP>
    #+end_example

    * 匿名函数/lambda函数
    #+begin_example
    ELISP> (lambda (x)(* x 10))
    (lambda
      (x)
      (* x 10))

    ELISP>

    ELISP> (funcall (lambda (x)(* x 10)) 5)
    50
    ELISP>

    ELISP> (setq my-lambda (lambda (x) (+ (* x 10) 5))) ;; 10 * x + 5
    (lambda
      (x)
      (+
       (* x 10)
       5))

    ELISP> (funcall my-lambda 10)
    105
    ELISP> (mapcar my-lambda '(1 2 3 4 5))
    (15 25 35 45 55)


    ELISP>  (setq double (function (lambda (x) (+ x x)) ))
    (lambda
      (x)
      (+ x x))

    ELISP> (funcall double 22)
    44
    ELISP>


    ;;
    ;; Apply a function to a list of arguments
    ;;
    ;;;;;;;;;;;

    ELISP> (apply #'+ '(1 2 3 4 5))
    15
    ELISP>

    ELISP>
    ELISP> (defun f (x y z) (+ (* 10 x) (* -4 y) (* 5 z)))
    f
    ELISP> (f 2 3 5)
    33

    ELISP> (apply 'f '(2 3 5))
    33


    ELISP> (mapcar (lambda (x) (apply 'f x)) '( (2 3 5) (4 5 6) (8 9 5)))
    (33 50 69)



    ;; Create Higher Order Functions
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    #+end_example 

    * Function Composition ????
    #+begin_example
    ELISP> ;; ID: f0c736a9-afec-3e3f-455c-40997023e130
    (defun compose (&rest funs)
      "Return function composed of FUNS."
      (lexical-let ((lex-funs funs))
	(lambda (&rest args)
	  (reduce 'funcall (butlast lex-funs)
		  :from-end t
		  :initial-value (apply (car (last lex-funs)) args)))))
		  compose

    ELISP> (funcall (compose 'prin1-to-string 'random* 'exp) 10)
    "4757.245739507558"
    ELISP>
    #+end_example 

    * Interactive Functions
    #+begin_example
    (defun some-interactive-function ()
       "Documentation"
      (interactive)
      ...)
    #+end_example

    * List Recursive Functions
    *Map*
    #+begin_example
   (defun map (fun xs)
     (if (null xs)
	 '()
       (cons (funcall fun (car xs))
	 (map fun (cdr xs)))))

   ELISP> (map #'buffer-name (buffer-list))
   ("*ielm*" "*scratch*" " *Minibuf-1*" "*Backtrace*" "*eshell*" "sclj.import.scm" "*Messages*" "*GNU Emacs*" " *Minibuf-0*" " *code-conversion-work*" " *Echo Area 0*" " *Echo Area 1*" "*Shell Command Output*" "*Completions*")

   ELISP>
   #+end_example

    *Filter*
    #+begin_example
    (defun filter (fun xs)
      (if (null xs)
	  '()
	(let ((hd (car xs))
	  (tl (cdr xs)))
	  (if (funcall fun hd)
	  (cons hd (filter fun tl))
	(filter fun tl)))))

    (defun odd? (x) (zerop (% x 2)))

    ELISP> (filter #'odd? '(1 2 3 4 5 6))
    (2 4 6)
    #+end_example

    *Take*

    #+BEGIN_SRC emacs-lisp
    (defun take (n xs)
      (if (or (null xs) (zerop n))
	  '()
	(cons (car xs)
	      (take (- n 1) (cdr xs)))))


    ELISP> (take 5 '(a b c d e f g h i j))
    (a b c d e)

    ELISP> (take 10 '(a b c d e f g h i j))
    (a b c d e f g h i j)

    ELISP> (take 200 '(a b c d e f g h i j))
    (a b c d e f g h i j)

    ELISP> (take 0 '(a b c d e f g h i j))
    nil
    ELISP> (take 10 '())
    nil
    ELISP>
    #+END_SRC

    *Drop*

    #+BEGIN_SRC emacs-lisp
    (defun drop (n xs)
      (if (or (null xs) (zerop n))
	  xs
	(drop (- n 1)  (cdr xs))))

    ELISP> (drop 3 '(a b c d e f g h i j))
    (d e f g h i j)

    ELISP> (drop 4 '(a b c d e f g h i j))
    (e f g h i j)

    ELISP> (drop 25 '(a b c d e f g h i j))
    nil
    ELISP>
    #+END_SRC

    *Map-apply*

    #+BEGIN_SRC emacs-lisp
    (defun map-apply (fun xss)
      (mapcar (lambda (xs) (apply fun xs)) xss))

    ELISP> (map-apply #'fxyz '((1 2 3) (3 4 5) (2 3 1)))
    (17 35 20)

    ELISP> (fxyz 1 2 3)
    17
    ELISP> (fxyz 3 4 5)
    35
    ELISP> (fxyz 2 3 1)
    20
    ELISP>
    #+END_SRC

    *Zip*

    #+BEGIN_SRC emacs-lisp
    (defun zip (&rest xss)
      (if (null (car xss))
	  '()
	(cons
	 (mapcar #'car xss)
	 (apply #'zip (mapcar #'cdr xss)))))

    ELISP> (zip (list 1 2 3 4) '(a b c d) '(x y z w))
    ((1 a x)
     (2 b y)
     (3 c z)
     (4 d w))
    #+END_SRC

    *Zipwith*

    #+BEGIN_SRC emacs-lisp
    (defun zipwith (f &rest xss)
      (map-apply f (apply #'zip xss)))

    ELISP> (zipwith #'f '(1 2 3) '(4 5 6) '(3 6 8))
    (23 40 53)

    ELISP> (f 1 4 3)
    23

    ELISP> (f 2 5 6)
    40

    ELISP> (f 3 6 8)
    53
    ELISP>
    #+END_SRC

    *Foldr*

    #+BEGIN_SRC emacs-lisp
    ;;           f :: x -> acc -> acc
    ;; foldr :: (a -> b -> b) -> b -> [a] -> b
    ;; foldr :: (x -> acc -> acc) -> acc -> [x] -> acc
    ;; foldr f z []     = z
    ;; foldr f z (x:xs) = f x (foldr f z xs)
    ;;
    ;;  x = (car xss) , xs = (cdr xss)
    (defun foldr (f acc xss)
      (if (null xss)
	  ;; foldr f z []     = z
	  acc
	;; foldr f z (x:xs) = f x (foldr f z xs)
	(funcall f (car xss)
		 (foldr f acc (cdr xss)))))

    ELISP> (foldr (lambda (a b) (+ (* 10 b) a)) 0 '(1 2 3 4 5))
    54321
    ELISP>

    ELISP> (foldr #'+ 0 '(1 2 3 4 5))
    15
    ELISP>
    #+END_SRC

    *Foldl*

    #+BEGIN_SRC emacs-lisp
    ;; foldl :: (b -> a -> b) -> b -> [a] -> b
    ;; foldl f z []     = z
    ;; foldl f z (x:xs) = foldl f (f z x) xs
    (defun foldl (f acc xss)
      (if (null xss)
	  acc
	(foldl f (funcall f acc (car xss)) (cdr xss))))

    ELISP> (foldl (lambda (a b) (+ (* 10 a) b)) 0 '(1 2 3 4 5))
    12345
    ELISP>
    #+END_SRC

    *Map Pairs*

    #+BEGIN_SRC emacs-lisp
    (defun map-pair (func xs)
      (mapcar (lambda (x) (cons x (funcall func x))) xs))

    ELISP> (map-pair #'1+ '(1 2 3 4))
    ((1 . 2)
     (2 . 3)
     (3 . 4)
     (4 . 5))

    ELISP> (map-pair #'log10 '(1 10 100 1000 10000))
    ((1 . 0.0)
     (10 . 1.0)
     (100 . 2.0)
     (1000 . 3.0)
     (10000 . 4.0))

    (defun buffer-mode (buffer-or-string)
      "Returns the major mode associated with a buffer."
      (with-current-buffer buffer-or-string
	major-mode))

    ELISP> (map-pair #'buffer-mode (buffer-list))
    ((#<buffer *ielm*> . inferior-emacs-lisp-mode)
     (#<buffer *scratch*> . lisp-interaction-mode)
     (#<buffer *Backtrace*> . debugger-mode)
     (#<buffer *GNU Emacs*> . fundamental-mode)
     (#<buffer  *Minibuf-1*> . minibuffer-inactive-mode)
     (#<buffer  *Minibuf-0*> . minibuffer-inactive-mode)
     (#<buffer *Messages*> . messages-buffer-mode)
    #+END_SRC

    *Map pairs xy*

    #+BEGIN_SRC emacs-lisp
    (defun map-xypair (func-x func-y xs)
      (mapcar
       (lambda (x)
	 (cons (funcall func-x x) (funcall func-y x)))
       xs))

    ELISP> (map-xypair #'buffer-name #'buffer-mode (buffer-list))
    (("*ielm*" . inferior-emacs-lisp-mode)
     ("*scratch*" . lisp-interaction-mode)
     ("*Backtrace*" . debugger-mode)
     ("*GNU Emacs*" . fundamental-mode)
     (" *Minibuf-1*" . minibuffer-inactive-mode)
     (" *Minibuf-0*" . minibuffer-inactive-mode)
     ("*Messages*" . messages-buffer-mode)
     (" *code-conversion-work*" . fundamental-mode)
     (" *Echo Area 0*" . fundamental-mode)
     (" *Echo Area 1*" . fundamental-mode)
     (" *http www.httpbin.org:80*" . fundamental-mode)
     (" *http www.httpbin.org:80*-820734" . fundamental-mode)
     (" *http www.httpbin.org:80*-914099" . fundamental-mode)
     (" *http www.httpbin.org:80*-945998" . fundamental-mode)
     ("*Help*" . help-mode)
     ("*Completions*" . completion-list-mode))
    #+END_SRC

    *Juxt*

    #+BEGIN_SRC emacs-lisp
    ELISP> (juxt #'buffer-name #'buffer-mode)
    (lambda
      (x)
      (list
       ((funcall #'buffer-name x)
	(funcall #'buffer-mode x))))


    ELISP> (funcall (juxt #'buffer-file-name  #'buffer-name #'buffer-mode) (current-buffer))
    (nil "*ielm*" inferior-emacs-lisp-mode)

    ELISP> (mapcar (juxt #'buffer-name #'buffer-file-name #'buffer-mode) (buffer-list))
    (("*ielm*" nil inferior-emacs-lisp-mode)
     ("*scratch*" nil lisp-interaction-mode)
     ("passgen.py" "/home/tux/bin/passgen.py" python-mode)
     (".bashrc" "/home/tux/.bashrc" sh-mode)
     (" *Minibuf-1*" nil minibuffer-inactive-mode)
     ("init.el" "/home/tux/.emacs.d/init.el" emacs-lisp-mode)
     ("*Backtrace*" nil debugger-mode)
     ("*GNU Emacs*" nil fundamental-mode)
     (" *Minibuf-0*" nil minibuffer-inactive-mode)
     ("*Messages*" nil messages-buffer-mode)
     (" *code-conversion-work*" nil fundamental-mode)
     (" *Echo Area 0*" nil fundamental-mode)
     (" *Echo Area 1*" nil fundamental-mode)
     (" *http www.httpbin.org:80*" nil fundamental-mode)
     (" *http www.httpbin.org:80*-820734" nil fundamental-mode)
     (" *http www.httpbin.org:80*-914099" nil fundamental-mode)
     (" *http www.httpbin.org:80*-945998" nil fundamental-mode)
     ("*Help*" nil help-mode)
     ("*Completions*" nil completion-list-mode))
    #+END_SRC

    *Map Juxt*

    #+BEGIN_SRC emacs-lisp
    (defmacro map-juxt (xs_f xs)
      `(mapcar (juxt ,@xs_f) ,xs))


    ELISP> (map-juxt (#'buffer-name #'buffer-file-name #'buffer-mode) (buffer-list))
    (("*ielm*" nil inferior-emacs-lisp-mode)
     ("*scratch*" nil lisp-interaction-mode)
     ("passgen.py" "/home/tux/bin/passgen.py" python-mode)
     (".bashrc" "/home/tux/.bashrc" sh-mode)
     (" *Minibuf-1*" nil minibuffer-inactive-mode)
     ("init.el" "/home/tux/.emacs.d/init.el" emacs-lisp-mode)
     ("*Backtrace*" nil debugger-mode)
     ("*GNU Emacs*" nil fundamental-mode)
     (" *Minibuf-0*" nil minibuffer-inactive-mode)
     ("*Messages*" nil messages-buffer-mode)
     ...
    #+END_SRC

    *Lambda Function Macro*

    #+BEGIN_SRC emacs-lisp
    (defmacro $f (f &rest params)
      `(lambda ($) (,f ,@params)))


    ELISP> ($f - 10 $)
    (lambda
      ($)
      (- 10 $))

    ELISP> ($f * (+ 3 $) 5)
    (lambda
      ($)
      (*
       (+ 3 $)
       5))

    ELISP> (funcall ($f * (+ 3 $) 5) 10)
    65
    ELISP> (mapcar  ($f * (+ 3 $) 5) '(1 2 3 4 5))
    (20 25 30 35 40)

    ELISP>
    ELISP> (mapcar  ($f list (1+ $) (1- $) (log10 $)) '(1 10 100 1000))
    ((2 0 0.0)
     (11 9 1.0)
     (101 99 2.0)
     (1001 999 3.0))
    #+END_SRC

    *Partial Application*

    #+BEGIN_SRC emacs-lisp
    (defmacro $c (f  &rest params)
      `(lambda (__x) (,f ,@params __x)))

    ELISP> (defun f (x y z) (+ (* 3 x) (* 2 y) (* 4 z)))
    f
    ELISP> (f 1 2 3)
    19
    ELISP> ($c f 1 2)
    (lambda
      (__x)
      (f 1 2 __x))

    ELISP> (mapcar ($c f 1 2) '(1 2 3 4 5))
    (11 15 19 23 27)

    ELISP> (mapcar ($c + 1 2) '(1 2 3 4 5))
    (4 5 6 7 8)

    ELISP>
    #+END_SRC

** Structures

   #+BEGIN_SRC emacs-lisp
   ELISP> (defstruct account id name balance)
   account
   ELISP> (make-account :id 3434 :name "John" :balance 1000.34)
   [cl-struct-account 3434 "John" 1000.34]

   ELISP> (setq user1 (make-account :id 3434 :name "John" :balance 1000.34))
   [cl-struct-account 3434 "John" 1000.34]

   ELISP> (account-name user1)
   "John"

   ELISP> (account-id user1)
   3434

   ELISP> (account-balance user1)
   1000.34

   ;; Test if input is an account object
   ;;
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ELISP> (account-p user1)
   t
   ELISP>

   ;; Change Field
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ELISP> (defun withdraw (accc amount)
	    (setf (account-balance acc) (- (account-balance acc) amount)))
   withdraw

   ELISP> (withdraw user1 300)
   700.34
   ELISP> user1
   [cl-struct-account 3434 "John" 700.34]

   ELISP> (withdraw user1 500)
   200.34000000000003
   ELISP> user1
   [cl-struct-account 3434 "John" 200.34000000000003]

   ELISP>

   ;; Build structure from a list of parameters
   ;;
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

   ELISP> (defun build-account (id name balance)
	    (make-account :id id :name name  :balance balance))
   build-account

   ELISP> (build-account 3434 "O' Neil" 35434.23)
   [cl-struct-account 3434 "O' Neil" 35434.23]

   ELISP> (apply 'build-account '(3434 "O' Neil" 35434.23))
   [cl-struct-account 3434 "O' Neil" 35434.23]

   ELISP>

   ELISP> (mapcar (lambda (params) (apply 'build-account params))
		  '(
		    (34423 "O' Neil" 23.2323)
		    (1023  "John Edwards" 1002323.23)
		    (92323 "Mr. Dummy"  2323241.2323)
		    (8723  "John Oliver" 9823)
		    ))
   ([cl-struct-account 34423 "O' Neil" 23.2323]
    [cl-struct-account 1023 "John Edwards" 1002323.23]
    [cl-struct-account 92323 "Mr. Dummy" 2323241.2323]
    [cl-struct-account 8723 "John Oliver" 9823])

   ELISP>

   ELISP> (defun build-accounts-from-list (list-of-params)
	    (mapcar (lambda (params) (apply 'build-account params)) list-of-params))
   build-accounts-from-list
   ELISP>

   ELISP> (setq accounts (build-accounts-from-list
			  '(
			    (34423 "O' Neil" 23.2323)
			    (1023  "John Edwards" 1002323.23)
			    (92323 "Mr. Dummy"  2323241.2323)
			    (8723  "John Oliver" 9823)
			    )))
   ([cl-struct-account 34423 "O' Neil" 23.2323]
    [cl-struct-account 1023 "John Edwards" 1002323.23]
    [cl-struct-account 92323 "Mr. Dummy" 2323241.2323]
    [cl-struct-account 8723 "John Oliver" 9823])

   ELISP> accounts
   ([cl-struct-account 34423 "O' Neil" 23.2323]
    [cl-struct-account 1023 "John Edwards" 1002323.23]
    [cl-struct-account 92323 "Mr. Dummy" 2323241.2323]
    [cl-struct-account 8723 "John Oliver" 9823])

   ELISP> (mapcar #'account-id accounts)
   (34423 1023 92323 8723)

   ELISP>

   ELISP>
   ELISP> (mapcar #'account-name accounts)
   ("O' Neil" "John Edwards" "Mr. Dummy" "John Oliver")

   ELISP>


   ELISP> (mapcar #'account-balance accounts)
   (23.2323 1002323.23 2323241.2323 9823)

   ELISP>
   #+END_SRC

*  宏和元编程
** Quasi-quote

   #+BEGIN_SRC emacs-lisp
   ;;;; Quasiquote

   > `(the product of 3 and 4 is ,(* 3 4))
   (the product of 3 and 4 is 12)

   > `("the product of 3 and 4 is" ,(* 3 4))
   ("the product of 3 and 4 is" 12)

   > `("the value of (exp 3) is " ,(exp 3) "the value of (sqrt 100) is" ,(sqrt 100))
   ("the value of (exp 3) is " 20.085536923187668 "the value of (sqrt 100) is" 10.0)

   > `(a ,a b ,b c ,c d ,d)
   (a 10 b 20 c my-symbol d "a string")

   > `((a . ,a) (b . ,b) (c . ,c) (d . ,d))
   ((a . 10)
    (b . 20)
    (c . my-symbol)
    (d . "a string"))

   > (setq xs '(sym1 sym2 sym3))
   (sym1 sym2 sym3)

   > xs
   (sym1 sym2 sym3)

   > `(xs ,xs)
   (xs
    (sym1 sym2 sym3))

   > `(xs ,@xs)
   (xs sym1 sym2 sym3)

   > `(if (< ,a ,b) ,(+ a 4) ,d)
   (if
       (< 10 20)
       14 "a string")

   > (eval `(if (< ,a ,b) ,(+ a 4) ,d))
   14
   >

   > (eval `(if (> ,a ,b) ,(+ a 4) ,d))
   "a string"

   ;;------------------

   > (setq xlist '(1 2 3 4))
   (1 2 3 4)

   > (setq ylist '(a b c d e))
   (a b c d e)

   > `(xs ,xlist ys ,ylist)
   (xs
    (1 2 3 4)
    ys
    (a b c d e))

   > `(xs ,@xlist ys ,@ylist)
   (xs 1 2 3 4 ys a b c d e)
   #+END_SRC

** 宏 
   *定义lambda函数语法糖:λ*

   #+BEGIN_SRC emacs-lisp
   (defmacro λ (args body)
     `(lambda ,args ,body))

   ELISP> (λ (x) (+ x 3))
   (lambda
     (x)
     (+ x 3))
   ELISP> (mapcar (λ (x) (+ x 3)) '(1 2 3 4 5 6))
   (4 5 6 7 8 9)
   #+END_SRC

   *Set variable to nil*

   #+BEGIN_SRC emacs-lisp
   (defmacro nil! (var)
     `(setq ,var nil))

   ELISP> (setq x 10)
   10
   ELISP> x
   10
   ELISP>

   ELISP> (nil! x)
   nil
   ELISP> x
   nil
   ELISP>

   ELISP> (nil! z)
   nil
   ELISP> z
   nil
   ELISP>
   #+END_SRC

   *Create Clojure def, defn and fn special forms*

   #+BEGIN_SRC emacs-lisp
   (defmacro fn (args body)
     `(lambda ,args ,body))

   (defmacro def (name value)
     `(setq ,name ,value))

   (defmacro defn (name args body)
     `(defun ,name ,args ,body))

   ELISP> (fn (x) (* x x))
   (lambda
     (x)
     (* x x))

   ELISP> (mapcar (fn (x) (* x x)) '(1 2 3 4 5))
   (1 4 9 16 25)

   ELISP> (def x 1000)
   1000
   ELISP> x
   1000
   ELISP>

   ELISP> (defn f (x y z) (+ (* 3 x) (* -4 y) (* 5 z)))
   f
   ELISP> (f 4 5 6)
   22
   ELISP>
   #+END_SRC

   ......

* Emacs API
** Emacs术语

   | Emacs Terminology | Description                                                                                    |
   |-------------------+------------------------------------------------------------------------------------------------|
   | Point             | Cursor position, number of characters from beggining of the buffer to current cursor position. |
   | Buffer            | Place where the user edit something. Not all buffers are bound to a file.                      |
   | Mark              | Beginning of the selected area.                                                                |
   | Region            | Selected area/ text                                                                            |
   | Frame             | The current window of emacs                                                                    |
   | Windows           | Each frame can be split in sections that Emacs documentation calls windows                     |
   | Fill              | Word Wrap                                                                                      |
   | Yank              | Copy                                                                                           |
   | Kill Region       | Cut                                                                                            |
   | Kill Ring         | Clipboard                                                                                      |
   | Kill Buffer       | Close Buffer                                                                                   |
   | Mode Line         | Status Bar                                                                                     |
   | Font Locking      | Syntax Coloring                                                                                |

   [[http://www.blogbyben.com/2011/04/10-concepts-emacs-newbie-should-master.html][Ben's Journal: 11 Concepts The Emacs Newbie Should Master]]
** Emacs API
   *API对象*
   * Buffer
   * Temporary Buffer
   * Modes
   * Mode Hooks
   * Mode Map
   * Window
   * Frame
   * Point
   * Process
   * Network Process
   * Minibuffers

** Buffers
*** Buffer Attributes
    #+BEGIN_SRC emacs-lisp
    (buffer-list)
    (current-buffer)
    (mapcar #'buffer-name (buffer-list))
    (mapcar #'buffer-file-name (buffer-list))
    (kill-buffer "init.el")
    (get-buffer "*scratch*")
    #+END_SRC

    *列出打开文件*

    #+BEGIN_SRC emacs-lisp
    (defun opened-files ()
      "list all opened file in current session"
      (interactive)
      (remove-if 'null (mapcar 'buffer-file-name (buffer-list))))

    (opened-files)
    #+END_SRC

    *创建新buffer*

    #+BEGIN_SRC emacs-lisp
    ;;
    ;;
    ;; This function returns a buffer named  buffer-or-name.
    ;; The buffer returned does not become the current
    ;; buffer—this function does not change which buffer is current.
    ;;

    ELISP> (get-buffer-create "foobar")
    #<buffer foobar>
    ELISP>

    ;;
    ;;  Divide the screen in two windows, and switch to the new buffer
    ;;  window
    ;;
    ELISP> (switch-to-buffer-other-window "foobar")
    #<buffer foobar>
    ELISP>

    ;; Clean Current Buffer
    ;;
    ELISP> (erase-buffer)
    nil
    ELISP>

    ;;  Edit another buffer and go back to the old buffer
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ELISP> (defun within-buffer (name function)
	     (let (curbuff (current-buffer))
	       (switch-to-buffer name)
	       (funcall function)
	       (switch-to-buffer current-buffer)
	       ))

    ELISP> (within-buffer "foobar" (lambda () (insert "dummy")))
    #<buffer *ielm*>
    ELISP>
    ELISP> (lambda (x)(* x 10))
    (lambda
      (x)
      (* x 10))

    ;;;; Translated from: http://d.hatena.ne.jp/rubikitch/20100201/elispsyntax
    ;;
    ELISP> ;; test-buffer Create a buffer named, to write a variety of content
    (with-current-buffer (get-buffer-create "test-buffer")
      ;; Empty the contents of the buffer
      (erase-buffer)
      ;; /tmp/foo.txt Make the contents inserted
      (insert-file-contents "/etc/fstab")
      ;; Insert a string
      (insert "End\n")
      ;; Write the contents of a buffer to a file
      (write-region (point-min) (point-max) "/tmp/bar.txt"))
    nil
    ELISP>
    #+END_SRC
*** Buffer Mode
    *Show Buffers Mode*

    #+BEGIN_SRC emacs-lisp
    ELISP> (defun buffer-mode (buffer-or-string)
	     "Returns the major mode associated with a buffer."
	     (with-current-buffer buffer-or-string
	       major-mode))
    buffer-mode

    ELISP> (mapcar (lambda (b)(
			       let
			       (
				(name (buffer-name b))
				(type   (buffer-mode (buffer-name b)))
				)
			       (list name type)
			       ))
		   (buffer-list))
    (("*ielm*" inferior-emacs-lisp-mode)
     ("*SPEEDBAR*" speedbar-mode)
     (" *Minibuf-1*" minibuffer-inactive-mode)
     ("*scratch*" emacs-lisp-mode)
     ("test3.ml" tuareg-mode)
     ("*Help*" help-mode)
     ("*Messages*" messages-buffer-mode)
     ("sbet.ml" tuareg-mode)
     (" *Minibuf-0*" minibuffer-inactive-mode)
     ("test.el" emacs-lisp-mode)
     ...
    #+END_SRC
*** Get Buffer Contents / Selection / Line
    *Get Buffer Content as String*

    #+BEGIN_SRC emacs-lisp
    ELISP> (defun buffer-content (name)
	     (with-current-buffer name
	       (buffer-substring-no-properties (point-min) (point-max))))
    buffer-content
    ELISP>

    ELISP> (buffer-content "test3.ml")
    "\n\nlet rec prodlist = function \n    | [] ... "
    #+END_SRC

    *Get Selected text in current buffer as string*

    #+BEGIN_SRC emacs-lisp
    (defun get-selection ()
      "Get the text selected in current buffer as string"
      (interactive)
      (buffer-substring-no-properties (region-beginning) (region-end))
      )
    #+END_SRC

    *Get current line in current buffer*

    #+BEGIN_SRC emacs-lisp
    (defun get-current-line ()
      (interactive)
      "Get current line, where the cursor lies in the current buffer"
      (replace-regexp-in-string "[\n|\s\t]+$" "" (thing-at-point 'line t))
      )
    #+END_SRC
*** Search and Replace in the entire Buffer

    #+BEGIN_SRC emacs-lisp
    (defun replace-regexp-entire-buffer (pattern replacement)
      "Perform regular-expression replacement throughout buffer."
      (interactive
       (let ((args (query-replace-read-args "Replace" t)))
	 (setcdr (cdr args) nil)    ; remove third value returned from query---args
	 args))
      (save-excursion
	(goto-char (point-min))
	(while (re-search-forward pattern nil t)
	  (replace-match replacement))))
    #+END_SRC
** Point, Region, Line and Buffer
*** Point
    *Point*

    | Function                           | Description                                                          |
    |------------------------------------+----------------------------------------------------------------------|
    | (point)                            | Current cursor position                                              |
    | (point-min)                        | Minimum cursor position in current buffer. (always returns 1)        |
    | (point-max)                        | Maximum cursor position in current buffer.                           |
    |                                    |                                                                      |
    | (line-beginning-position)          | Point of the beginning of current line.                              |
    | (line-end-position)                | Point of the end of current line.                                    |
    |                                    |                                                                      |
    | (region-beginning)                 | Position of the beginning current region (selected text).            |
    | (region-end)                       | Position of the end current region.                                  |
    |                                    |                                                                      |
    | (bounds-of-thing-at-point <thing>) | Returns the cons pair '(beginning . end) position of thing at point. |

    *Point Interface Functions*

    | Function                                      | Description                                                            |
    |-----------------------------------------------+------------------------------------------------------------------------|
    | (goto-char <point>)                           | Move the cursor to a given point.                                      |
    | (insert <string>)                             | Insert text at current point.                                          |
    | (buffer-substring [pmin] [pmax])              | Returns the text with properties between the points <pmin> and <pmax>. |
    | (buffer-substring-no-properties [pmin] pmax]) | Returns the text without properties between the points.                |
    | (delete-region [pmin] [pmax])                 | Deletes the text between <pmin> and <pmax>.                            |


    #+BEGIN_SRC emacs-lisp
    > (point)
    99696

    > (point-min)
    1


    > (point-max)
    185623

    >  (line-beginning-position)
    99774

    >  (line-end-position)
    99804

    > (buffer-substring-no-properties
       (line-beginning-position)
       (line-end-position))

    (defun delete-line ()
      (interactive)
      (delete-region  (line-beginning-position)  (line-end-position)))

    (defun delete-region ()
      (interactive)
      (delete-region  (region-beginning) (region-end)))

    (defun insert-end-of-buffer ()
      (interactive)

      ;; Save Current Cursor Position
      ;; and go back to initial positon when
      ;; finish this block
      (save-excursion
	(goto-char (point-max)) ;;; Go to end of buffer
	(insert "Testing insert end of buffer")
	))
    #+END_SRC
*** Thing at Point API
    ???
** Message / Output

   #+BEGIN_SRC emacs-lisp
   (message "Hello world")
   (message-box "Time for a break.\nDrink some coffee")
   #+END_SRC
** Files, Directories and Path
*** Basic Functions

    #+BEGIN_SRC emacs-lisp
    ;; Get and Set current directory

    ELISP> (pwd)
    "Directory /home/tux/tmp/"

    ELISP> (cd "/etc/")
    "/etc/"

    ELISP> (pwd)
    "Directory /etc/"
    ELISP>


    ELISP> (file-name-directory "/etc/hosts")
    "/etc/"

    ;; Expand File Name
    ;;
    ELISP> (expand-file-name "~/")
    "/home/tux/"
    ELISP> (expand-file-name ".")
    "/home/tux/tmp"
    ELISP> (expand-file-name "..")
    "/home/tux"
    ELISP>


    ;;;;; Create a Directory
    ;;;
    ELISP> (mkdir "dummy")
    nil
    ELISP> (mkdir "dummy")
    ,** Eval error **  File exists: /home/tux/dummy
    ELISP>

    ;;; List Directory
    ;;;;
    ;;;
    ELISP> (directory-files "/home/tux/PycharmProjects/Haskell/")
    ("." ".." ".git" ".gitignore" ".idea" "LICENSE" "Make" "Makefile"
     "README.back.md" "README.html" "README.md" "Test.html" "build.sh" "clean.sh"
     "codes" "dict.sh" "haskell" "ocaml" "papers" "tags" "tmp")
   #+END_SRC
*** File Name Components

   #+BEGIN_SRC emacs-lisp
   ELISP> (file-name-directory "/usr/bin/env")
   "/usr/bin/"
   ELISP>

   ELISP> (file-name-nondirectory "/usr/bin/env")
   "env"
   ELISP>


   ELISP> (file-name-base "/home/foo/zoo1.c")
   "zoo1"
   ELISP> (file-name-base "/home/foo/zoo1.c.back")
   "zoo1.c"
   #+END_SRC
*** Read / Write file to a string
*Read File*
   #+BEGIN_SRC emacs-lisp
   ELISP> (defun file-contents (filename)
     (interactive "fFind file: ")
     (with-temp-buffer
       (insert-file-contents filename) ;; 先将文件内容插入临时buffer，再读取内容
       (buffer-substring-no-properties (point-min) (point-max))))

   ELISP> (file-contents "/proc/filesystems")
   "nodev  sysfs\nnodev    rootfs\nnodev   ramfs\nnodev
   bdev\nnodev proc\nnodev cgroup\nnode ...
   #+END_SRC

    *Write to File*
   #+BEGIN_SRC emacs-lisp
   ELISP> (append-to-file "hello world" nil "/tmp/hello.txt")
   nil

   ELISP> (file-contents "/tmp/hello.txt")
   "hello world"
   ELISP>
   #+END_SRC
** Window Functions
*** Basic Window Functions

    #+BEGIN_SRC emacs-lisp
    (split-window-horizontally)
    (split-window-vertically)
    (delete-other-windows)
    (switch-to-buffer-other-window "init.el")
    (delete-window)
    (make-frame)
    (frame-list)
    (delete-frame)
    #+END_SRC
*** Manipulate Buffer in Another Window
    http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-3-9-2
*** Window Configuration

    #+BEGIN_SRC emacs-lisp
    (current-window-configuration)
    (setq w (current-window-configuration))
    w
    (set-window-configuration w)
    #+END_SRC


    #+BEGIN_SRC emacs-lisp
    ;; Screen Resolution

    ELISP> (x-display-pixel-width)
    1366

    ELISP> (x-display-pixel-height)
    768
    ELISP>
    ELISP>

    ;; Resize and Set Emacs Windows position
    ;;
    ;; From: http://uce.uniovi.es/tips/Emacs/mydotemacs.html#sec-41
    ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ELISP> (defun resize-frame ()
      "Set size"
      (interactive)
      (set-frame-width (selected-frame) 100)
      (set-frame-height (selected-frame) 28)
      (set-frame-position (selected-frame) 0 1))
    resize-frame
    ELISP>

    ELISP> (resize-frame)
    t
    ELISP>
    #+END_SRC

** OS Interface   
*** Find the current operating system

   | Value        | Description                       |
   |--------------+-----------------------------------|
   | gnu          | GNU Hurd system.                  |
   | gnu/linux    | GNU/Linux system.                 |
   | gnu/kfreebsd | GNU system with a FreeBSD kernel. |
   | darwin       | Darwin (GNU-Darwin, Mac OS X)     |
   | ms-dos       | MS-DOS application.               |
   | windows-nt   | native W32 application.           |
   | cygwin       | compiled using the Cygwin library |

   #+BEGIN_SRC emacs-lisp
   system-type
   system-configuration
   #+END_SRC

*** Date and Time
    #+BEGIN_SRC emacs-lisp
    (current-time)
    (insert (format-time-string "%Y-%m-%d")) ;; 2019-12-15
    (insert (format-time-string "%H:%M:%S")) ;; 16:11:04
    (format-time-string "%d/%m/%Y %H:%M:%S" (current-time))
    #+END_SRC

*** Call External Commands or Apps

    #+BEGIN_SRC emacs-lisp
    (call-process "mpd")
    (shell-command-to-string "pwd")
    #+END_SRC

*** Environment Variables

    #+BEGIN_SRC emacs-lisp
    (getenv "PATH")
    (split-string (getenv "PATH") ":")
    (dolist (e (split-string  (getenv "PATH") ":")) (princ (format "%s\n" e)))
    exec-path
    (getenv "HOME")
    (setenv "JAVA_HOME" "/usr/local/java")

    system-type
    (eq system-type 'gnu/linux)()
    (dolist (e process-environment) (princ (format "%s\n" e)))
    #+END_SRC

*** Process Management

    #+BEGIN_SRC emacs-lisp
    (process-list)
    (get-process "merlin")
    (mapcar 'process-name (process-list))

    ;;;; Buffer Process
    (process-command (get-process "vterm"))
    (process-id (get-process "vterm"))
    (process-buffer (get-process "vterm"))
    (buffer-name (process-buffer (get-process "vterm")))
    (mapcar (lambda (p) (buffer-name (process-buffer p))) (process-list))
    (display-buffer (process-buffer (get-process "vterm")))

    ;;;; Start Asyncronous Process
    ;;  Start the process named py, with the buffer named pybff
    ;;  using the command python, /usr/bin/python (on linux)
    (start-process "py" "pybff" "python")
    ;; End the process named py
    (process-send-eof "py")

    (process-send-string "py" "print 'Hello world'\n")

    ;;;; Get Multiple Fields

    (mapcar
     (lambda (p)(list
		 p
		 (process-name p)
		 (process-command p)
		 (list (process-buffer p) (buffer-name (process-buffer p)))
		 (process-id p)
		 (process-status p)
		 ))
     (process-list))
    #+END_SRC

** Interfaces
*** Creating Quick Access Menu 

    #+BEGIN_SRC emacs-lisp
    (require 'easymenu)

    (easy-menu-define djcb-menu global-map "Utils"
      '("Utils"
	("Shells" ;; submenu
	 ["Ielm   - Emacs Lisp Shell"       (ielm)]
	 ["Eshell - Emacs Buitin Shell"    (eshell)]
	 ["Native Shell "                  (shell)]
	 ["---------------------" nil]
	 ["Edit .bashrc" (find-file  "~/.bashrc")]
	 ["Edit .profile" (find-file "~/.profile")]
	 ["Edit .Xresources" (find-file "~/.Xresources")]
	 ["Edit .xsessin"    (find-file "~/.xsession")]
	 ["See all GNU MAN pages" ( info)]
	 ["See a specific Man Page" (woman)]

	 );; End of shells menu

	("Emacs /Elisp"  ;; submenu

	 ["Ielm   - Emacs Lisp Shell"  (ielm)]
	 ["Eval buffer"   (eval-buffer) ]
	 ["---------------------" nil]

	 ["Edit  init.el" (find-file  user-init-file)]
	 ["Reload init.el" (load-file user-init-file)]
	 ["Open .emac.d dir" (find-file "~/.emacs.d")]
	 ["List packages"     (list-packages)]
	 ["Install package"   (package-install)]

	 ) ;; End of Emacs / Elisp submenu
	)) ;; End of Custom Menu
    #+END_SRC

*** Add Icons to toolbar
http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-3-11-2
** Timer
*** run-with-timer

#+BEGIN_SRC emacs-lisp
;;; (run-with-timer SECS REPEAT FUNCTION &rest ARGS)
(run-with-timer 5 nil
		(lambda () (message-box "happy hacking emacs!")))

(defun cofee-wait ()
  (interactive)
  (let ((minutes 3))
    (run-with-timer (* 60 minutes)  nil
		    (lambda () (message-box "Coffee done"))
		    )
    (message "Waiting for the cofee")
    ))
#+END_SRC
** Emacs Modes
*** Mode Association with Files

#+BEGIN_SRC emacs-lisp
;; 列出所有和拓展名相关的mode
auto-mode-alist
;; 列出与一个mode相关的所有拓展名
(remove-if-not
 (lambda (al) (equal (cdr al) 'web-mode)) auto-mode-alist)
;; 为一个mode关联拓展名
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
#+END_SRC

*** Lisp Routines to introspect modes??

#+BEGIN_SRC emacs-lisp
(defun show-doc (function)
  (princ (documentation function)))

(defun mode/show ()
  "  Returns all modes associated with files

     To query the file extesions associated with a mode
     use:
         > (mode/ftypes 'markdown-mode)

     for example.
  "
  (dolist (m (remove-if #'listp
			(mapcar #'cdr auto-mode-alist))) (print m)))

(defun mode/ftypes (mode)
  "
  Get all file extension associated with a mode.

  Usage:

  ELISP> (get-mode-ftypes 'markdown-mode)
  ((\"\\.md\\'\" . markdown-mode)
  (\"\\.text\\'\" . markdown-mode)
  (\"\\.markdown\\'\" . markdown-mode)

  "
  (remove-if-not
   (lambda (al)
     (equal (cdr al) mode))
   auto-mode-alist))

ELISP> (mode/ftypes 'clojure-mode)
(("\\(?:build\\|profile\\)\\.boot\\'" . clojure-mode)
 ("\\.\\(clj\\|dtm\\|edn\\)\\'" . clojure-mode))

ELISP> (mode/ftypes 'scheme-mode)
(("\\.\\(scm\\|stk\\|ss\\|sch\\)\\'" . scheme-mode)
 ("\\.scm\\.[0-9]*\\'" . scheme-mode)
 ("\\.oak\\'" . scheme-mode))

ELISP> (show-doc #'mode/ftypes)

Get all file extension associated with a mode.

Usage:

ELISP> (get-mode-ftypes 'markdown-mode)
(("\.md\'" . markdown-mode)
 ("\.text\'" . markdown-mode)
 ("\.markdown\'" . markdown-mode))
#+END_SRC

*** Mode Specific Key Bindings

#+BEGIN_SRC emacs-lisp
(define-key emacs-lisp-mode-map (kbd "<f5>")
  (lambda () (interactive) (message "Hello world")))
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

** Special Variables

#+BEGIN_SRC emacs-lisp
emacs-major-version
load-path
window-system
system-type
system-configuration
shell-file-name
user-full-name
user-mail-address
user-init-file
user-emacs-directory
exec-directory
#+END_SRC

** Network
http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-3-15

* 正则表达式
**  Emacs Regex
*Special characters*

| .       | any character (but newline)                            |
| *       | previous character or group, repeated 0 or more time   |
| +       | previous character or group, repeated 1 or more time   |
| ?       | previous character or group, repeated 0 or 1 time      |
| ^       | start of line                                          |
| $       | end of line                                            |
| […]     | any character between brackets                         |
| [^..]   | any character not in the brackets                      |
| [a-z]   | any character between a and z                          |
| \       | prevents interpretation of following special char      |
| \       | or                                                     |
| \w      | word constituent                                       |
| \b      | word boundary                                          |
| \sc     | character with c syntax (e.g. \s- for whitespace char) |
|         | start\end of group                                     |
| \<      | \> start\end of word                                   |
| \`      | \' start\end of buffer                                 |
| \1      | string matched by the first group                      |
| \n      | string matched by the nth group                        |
| \{3\}   | previous character or group, repeated 3 times          |
| \{3,\}  | previous character or group, repeated 3 or more times  |
| \{3,6\} | previous character or group, repeated 3 to 6 times     |

*POSIX Character classes*


 	 
| [:digit:]	  | digit, same as [0-9]                                 |
| [:upper:]	  | letter in uppercase                                  |
| [:space:]          | whitespace character, as defined by the syntax table |
| [:xdigit:]	 | hexadecimal digit                                    |
| [:cntrl:]	  | control character                                    |
| [:ascii:]	  | ascii character                                      |

*Syntax Classes*
 	 	 	 
| \s- | whitespace character      | \s/ | character quote character |
| \sw | word constituent          | \s$ | paired delimiter          |
| \s_ | symbol constituent        | \s' | expression prefix         |
| \s. | punctuation character     | \s< | comment starter           |
| \s( | open delimiter character  | \s> | comment starter           |
| \s) | close delimiter character | \s! | generic comment delimiter |
| \s" | string quote character    | \s  | generic string delimiter  |
| \s\ | escape character          |     |                           |

*Emacs X Perl Regex*

| Emacs Regex        | Perl Regex | Description                         |
|--------------------+------------+-------------------------------------|
|                    | ( )        | Capture group                       |
| \{ \}              | { }        |                                     |
| \s-                | \s         | White space                         |
| \1, \2, \3, \4     | $1, $2, $3 | Result of capture: search, replace. |
| [ ]                | [ ]        | Character class                     |
| [0-9] or [:digit:] | \d         | Digit from 0 to 9                   |
| \b                 | \b         | Word boundary                       |
| \w                 | \w         | Word character                      |
** Regex Commands

| C-M-s | incremental forward search matching regexp  |
| C-M-r | incremental backward search matching regexp |

*Buffer Commands*

| M-x replace-regexp         | replace string matching regexp                         |
| M-x query-replace-regexp   | same, but query before each replacement                |
| M-x align-regexp           | align, using strings matching regexp as delimiters     |
| M-x highlight-regexp       | highlight strings matching regexp                      |
| M-x grep                   | call unix grep command and put result in a buffer      |
| M-x lgrep                  | user-friendly interface to the grep command            |
| M-x rgrep                  | recursive grep                                         |
| M-x dired-do-copy-regexp   | copy files with names matching regexp                  |
| M-x dired-do-rename-regexp | rename files matching regexp                           |
| M-x find-grep-dired        | display files containing matches for regexp with Dired |

*Line Commands*

| Command (M-x command)           | Alias                     | Description                                      |
|---------------------------------+---------------------------+--------------------------------------------------|
| keep-lines                      | delete-non-matching-lines | Delete all lines except those containing matches |
| flush-lines                     | delete-matching-lines     | Delete lines containing matches                  |
| highlight-lines-matching-regexp | hi-lock-line-face-buffer  | Highlight lines matching regexp                  |
| occur                           | list-matching-lines       | Show lines containing a match                    |
| multi-occur                     |                           | Show lines in all buffers containing a match     |
| how-many                        | count-matches             | Count the number of strings matching regexp      |
** Regex Functions
*** match-string
*** match-end
*** match-beginning
*** re-search
*** re-search-forward
*** replace-string-in-regexp
*** replace-string
** Build regex interactively
M-x re-builder

M-x query-replace-regexp
** Emacs Regex rx-notation

#+BEGIN_SRC emacs-lisp
(require 'rx)

;;  (rx <patterns>)

ELISP> (rx digit)
"[[:digit:]]"

ELISP> (rx-to-string '(or "foo" "bar"))
"\\(?:\\(?:bar\\|foo\\)\\)"
#+END_SRC

| Description               | rx notation | Emacs regex              |
|---------------------------+-------------+--------------------------|
| Beginning of Line         | bol         | ^                        |
| End of Line               | eol         | $                        |
|                           |             |                          |
| Begining of String        | bos         | \\`                      |
| End of String             | eos         | =\\'=                    |
|                           |             |                          |
| Beginning of Word         | bow         | \\<                      |
| End of Word               | eow         | \\>                      |
|                           |             |                          |
| Digit 0 to 9              | digit       | \lbr\lbr:digit:\rbr\rbr  |
| Hexadecimal digit         | hex         | \lbr\lbr:xdigit:\rbr\rbr |
| Match ascii character     |             |                          |
| Match anything lower case | lower       | \lbr\lbr:lower:\rbr\rbr  |
| Match anything upper case | upper       | \lbr\lbr:upper:\rbr\rbr  |
|                           |             |                          |
| word                      |             | \sw                      |

/example/


#+BEGIN_SRC emacs-lisp
ELISP> (require 'rx)
rx

ELISP> (rx (+ digit))
"[[:digit:]]+"

ELISP> (rx digit (+ digit))
"[[:digit:]][[:digit:]]+"

ELISP> (rx bol (+ digit) eol)
"^[[:digit:]]+$"

ELISP> (rx (zero-or-more digit))
"[[:digit:]]*"

ELISP> (rx (one-or-more digit))
"[[:digit:]]+"

ELISP> (rx (or "cat" "rat" "dog"))
"\\(?:cat\\|dog\\|rat\\)"

;; (replace-regexp-in-string REGEXP REP STRING
;;      &optional FIXEDCASE LITERAL SUBEXP START)

ELISP> (replace-regexp-in-string
          (rx (or "cat" "rat" "dog"))
          ""
          "cat cata rat rat dograt dog cat2334 23rat2")
" a     2334 232"

;; Replaces only in the beggining of line
;;
ELISP>  (replace-regexp-in-string
          (rx bol (or "cat" "rat" "dog"))
          ""
          "cat cata rat rat dograt dog cat2334 23rat2")
" cata rat rat dograt dog cat2334 23rat2"


ELISP>  (replace-regexp-in-string
          (rx bow (or "cat" "rat" "dog") eow)
          ""
          "cat cata rat rat dograt dog cat2334 23rat2")
" cata   dograt  cat2334 23rat2"

ELISP>  (rx bow (or "cat" "rat" "dog") eow)
"\\<\\(?:cat\\|dog\\|rat\\)\\>"

;;  Removes all whitespaces
;;
ELISP>  (replace-regexp-in-string
          (rx (* whitespace))
          ""
          "cat cata rat rat dograt dog cat2334 23rat2")

"catcataratratdogratdogcat233423rat"

ELISP>  (replace-regexp-in-string
          (rx (* whitespace))
          ""
          "cat cata rat rat dograt dog cat2334 23rat2")

"catcataratratdogratdogcat233423rat"

;; Capture group
;;
ELISP>  (replace-regexp-in-string
          (rx (submatch bow (or "cat" "rat" "dog") eow))
          "(\\1)"
          "cat cata rat rat dograt dog cat2334 23rat2")

"(cat) cata (rat) (rat) dograt (dog) cat2334 23rat2"

ELISP> (rx (submatch bow (or "cat" "rat" "dog") eow))
"\\(\\<\\(?:cat\\|dog\\|rat\\)\\>\\)"
#+END_SRC

* Color Scheme
http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-5
* Key Bindings
http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html#sec-6
</description>
<author>Kinney Zhang</author>
<pubDate>2019-11-12</pubDate>
</item>
<item>
<title>使用org-mode撰写Jekyll blog</title>
<link>https://blog.geekinney.com/post/using-org-to-blog-with-jekyll.html</link>
<description>#+TITLE:使用org-mode撰写Jekyll blog 
#+DATE: 2019-09-03
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+CATEGORY: Emacs
#+INCLUDE: "../code/post-info.org"
#+TOC: headlines:2

Jekyll是使用ruby开发的静态网站生成器，它可以将不同的文本标记语言转变为静态html页面。Jekyll生成的静态站点可以被几乎所有的web server使用并且不需要额外的组件。Github Page就是使用Jekyll构建的。

这篇文章将讨论如何使用org-mode撰写，发布jekyll blog，我不会面面俱到地介绍每个概念，比如：什么是org-mode，什么是jekyll以及如何安装使用它们等。如果你对以上问题存疑，可以自行研究，参考 [[http://doc.norang.ca/org-mode.html][Org Mode - Organize Your Life In Plain Text!]] 和 [[https://jekyllrb.com/][jekyll官网]]。

Org-mode原生支持功能强大的HTML导出，但是没有内置关于blog的操作。

使用Org发布jekyll blog分为三步：

 * 使用org-mode撰写blog内容
 * 将org文件导出为html并放置在Jekyll项目中
 * 启动jekyll服务，将html格式的文章解析呈现

接下来，着重介绍使用org-mode管理jekyll的原理和workflow，包括必要的elisp代码及折腾心得。


* WorkFlow
  :PROPERTIES:
  :ID:       B8BD7823-FF2F-4133-B8D4-2369E01AFCEB
  :PUBDATE:  <2020-02-11 Tue 14:32>
  :END:
首先，总体浏览一下workflow。这个流程不算完美，但对于日常使用emacs的用户已经可以很方便的使用org-mode撰写、发布jekyll blog了。

 * 打开emacs, =M-x jekyll-draft-post= ,输入文章标题。emacs会在 =_draft= 目标下新建带有YAML信息的org文件。
 * 文章编辑完成后, =M-x jekyll-publish-post= 。emacs会将文章移动到 =_post= 目录下，并修改文件名为符合jekyll规范的名称(_yyyy-mm-dd-title.org_)。
 * 按键 =C-c C-e= 选择项目进行发布。发布后的org会转换成html格式保存在jekyll项目对应的 =_post= 目录下。
 * 访问 _https://localhost:4000_ ，本地预览文章效果。如果需要修改，修改后重新发布项目。
 * 确认无误后，git push 上传修改代码到github。

* 流程分析
  :PROPERTIES:
  :ID:       5EDF80EB-5BA3-4619-A3F9-A673AE5375F1
  :PUBDATE:  <2020-02-11 Tue 14:32>
  :END:
看了以上的workflow，读者可能会有些疑惑，下面对流程具体讲解并附上必要的代码。
** 目录结构
   :PROPERTIES:
   :ID:       C48C1F9D-ABC3-4557-A2AD-37093C642A0F
   :END:
注意区分两个概念：Jekyll Blog目录 和 Jekyll项目目录。Jekyll Blog中存在的是原始的Org文件，Jekyll项目中存放的是用于Jekyll解析的HTML文件。我将Org文件存储在云盘中，项目文件托管在Github Page。当然你也可以将两者放在同一个目录下托管，whatever~

我的Jekyll Blog目录放在 =~/iCloud/blog= 文件夹中，其中 =_drafts= 中为草稿，不会被导出, =_post= 中为待发布的post。当发布项目时, =_post= 中所有的org文件转换为HTML并发布到Jekyll项目根目录的 =_posts= 文件夹中。

Jekyll Blog目录结构如下：

#+BEGIN_SRC nohighlight
.
├── _drafts
│   └── using-org-to-blog-with-jekyll.org
├── _pages
│   └── bookmark.org
├── _posts
│   ├── 2019-03-30-emacs-learning-note.org
│   └── 2019-08-31-listen-music-in-emacs.org
└── assets
    ├── css
    ├── img
    └── js
#+END_SRC

目录结构变量定义的elisp代码：

#+BEGIN_SRC emacs-lisp
  (defvar jekyll-directory (expand-file-name "~/iCloud/blog/")
    "Path to Jekyll blog.")
  (defvar jekyll-drafts-dir "_drafts/"
    "Relative path to drafts directory.")
  (defvar jekyll-posts-dir "_posts/"
    "Relative path to posts directory.")
  (defvar jekyll-post-ext ".org"
    "File extension of Jekyll posts.")
#+END_SRC

Jekyll项目目录结构如下：

#+BEGIN_SRC nohighlight
.
|__ config.yml
|__ _includes
|__ _layouts
|    |- default.html
|    |- post.html
|__ _posts
|    |- 2019-03-30-emacs-learning-note.html
|    |- 2019-08-31-listen-music-in-emacs.html
|__ _site
|__ index.html
|__ assets
     |- js
     |- css
        |- style.css
#+END_SRC

** 创建draft文件
   :PROPERTIES:
   :ID:       0C530771-C695-454F-A475-90A1C82F6F5B
   :END:
根据 =jekyll-post-template= 变量的内容和输入信息，生成org文件。elisp代码如下：

#+BEGIN_SRC emacs-lisp
  (defvar jekyll-post-template
    "#+STARTUP: showall indent\n#+STARTUP: hidestars\n#+begin_export html\n---\ndate: \nlayout: post\ntitle: %s\nsubtitle: \nauthor: Geekinney\nheader-img: \ntags: \ncatalog: \n---\n#+end_export\n\n"
    "Default template for Jekyll posts. %s will be replace by the post title."
    )

  (defun jekyll-make-slug (s)
    "Turn a string into a slug."
    (replace-regexp-in-string
     " " "-" (downcase
              (replace-regexp-in-string
               "[^A-Za-z0-9 ]" "" s))))

  (defun jekyll-yaml-escape (s)
    "Escape a string for YAML."
    (if (or (string-match ":" s)
            (string-match "\"" s))
        (concat "\"" (replace-regexp-in-string "\"" "\\\\\"" s) "\"")
      s))

  (defun jekyll-draft-post (title)
    "Create a new Jekyll blog post."
    (interactive "sPost Title: ")
    (let ((draft-file (concat jekyll-directory jekyll-drafts-dir
                              (jekyll-make-slug title)
                              jekyll-post-ext)))
      (if (file-exists-p draft-file)
          (find-file draft-file)
        (find-file draft-file)
        (insert (format jekyll-post-template (jekyll-yaml-escape title))))))
#+END_SRC

值得注意的是，模版中的YAML信息被包裹在了 =#+begin_export html= 和 =#+end_export= 标签之间。该标签之间的文本在Org转为HTML时会以原始文本导出，这为Jekyll解析HTML文件提供了保证。

带有合法YAML信息的markdown或html文件才能被Jekyll正常解析，我的YAML模版为：

#+BEGIN_SRC YAML
---
date: 
layout: post
title: 
subtitle: 
author: Geekinney
header-img: 
tags: 
catalog: 
---
#+END_SRC

读者可以根据自己的项目需求修改 =jekyll-post-template= 变量。

** 从draft到post
   :PROPERTIES:
   :ID:       BE24D09E-117A-4965-8841-33DEA9BA9844
   :END:
将 =_drafts= 目录中的Org文件移到 =_posts= 中，在文件名前面加上日期。elisp代码如下：

#+BEGIN_SRC emacs-lisp
  (defun jekyll-publish-post ()
    "Move a draft post to the posts directory, and rename it so that it
   contains the date."
    (interactive)
    (cond
     ((not (equal
            (file-name-directory (buffer-file-name (current-buffer)))
            (concat jekyll-directory jekyll-drafts-dir)))
      (message "This is not a draft post."))
     ((buffer-modified-p)
      (message "Can't publish post; buffer has modifications."))
     (t
      (let ((filename
             (concat jekyll-directory jekyll-posts-dir
                     (format-time-string "%Y-%m-%d-")
                     (file-name-nondirectory
                      (buffer-file-name (current-buffer)))))
            (old-point (point)))
        (rename-file (buffer-file-name (current-buffer))
                     filename)
        (kill-buffer nil)
        (find-file filename)
        (set-window-point (selected-window) old-point)))))
#+END_SRC

** 项目发布
   :PROPERTIES:
   :ID:       3E4E7282-B879-4666-8716-B556CBBFAFA3
   :END:
Org-mode使用原生的项目发布功能就可以将 =_posts= 目录下的Org文件发布至Jekyll。配置 =org-publish-project-alist= 变量即可。变量参数设置如下：

#+BEGIN_SRC emacs-lisp
  (setq org-publish-project-alist
        '(
          ("jekyll-post"
           :base-directory "~/iCloud/blog/_posts"
           :base-extension "org"
           :publishing-directory "~/iCloud/huxBlog/_posts"
           :recursive nil
           :publishing-function org-html-publish-to-html
           :with-toc nil
           :headline-levels 4
           :auto-preamble nil
           :auto-sitemap nil
           :html-extension "html"
           :table-of-contents nil
           :section-numbers 2
           :body-only t
           )
	
          ("jekyll-static"
           :base-directory "~/iCloud/blog/assets/"
           :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|php"
           :publishing-directory "~/iCloud/huxBlog/assets"
           :recursive t
           :publishing-function org-publish-attachment)
	
          ("jekyll"
           :components ("jekyll-post" "jekyll-static"))
          ))

#+END_SRC

org-publish参数设置参考 [[https://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html][HTML publishing tutorial]]

=:body-only t= 表示只导出body标签之间的部分，因为其余的部分Jekyll已经构建好了。但是，由于Org导出的HTML的body标签之外包含一些CSS样式，这就埋下了一个隐患：部分org语法不能正常解析。需要手动添加缺失的CSS到Jekyll项目中。

** 添加缺失样式
   :PROPERTIES:
   :ID:       3FDE6E2B-8804-44C1-96EE-022647DB158A
   :END:
主要缺失的样式有：代码块，表格，下划线，以及org-mode特有的keyword，timestamp等。下面给出添加的CSS参考：

#+BEGIN_SRC css
  pre {
      background: #333;
      color: #ddd;
      overflow: auto;
      padding: 8pt;
      border: 1px solid #666;
      border-radius: 5px;
      font-size: 10pt;
      font-family: 'PT Mono', 'PT Mono', monospace;
      margin-top: 1em;
      margin-bottom: 1em;
  }
  table {
      font-size: 100%;
      border-collapse: collapse;
      margin: .5em 0;
  }
  th, td {
      border: 1px solid #777;
      padding: .3em;
      margin: 2px;
  }
  th {
      background: #eee;
  }
  table { border-collapse: collapse; }
  td, th {
      vertical-align: top;
  }
  .todo  { color: red; }
  .done { color: green; }
  .priority { font-family: monospace; color: orange; }
  p.verse { margin-left: 3%; }
  .timestamp { color: gray }
  .timestamp-kwd { color: #f59ea0; }
  .target { background-color: #551a8b; }
  .underline { text-decoration: underline; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   {margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
#+END_SRC

当然，你可以定制自己喜欢的样式，比如代码块的高亮可以使用 [[https://highlightjs.org][highlight.js]]。关于org导出为HTML的CSS设置参考 [[https://orgmode.org/org.html#CSS-support][The Org Manual | CSS support]]。

** elisp代码
   :PROPERTIES:
   :ID:       60BBDB5E-9ABD-4334-9436-CBFE5C2688C0
   :END:
完整的elisp package参考我的 [[https://github.com/Kinneyzhang/.emacs.d/blob/master/elisp/init-org-jekyll.el#L15][init-org-jekyll.el]]。

* 参考文档
  :PROPERTIES:
  :ID:       BD91D5A6-8067-4DF6-9FCB-58CF155C6318
  :PUBDATE:  <2020-02-11 Tue 14:32>
  :END:
 * [[https://orgmode.org/worg/org-tutorials/org-jekyll.html][Using org to Blog with Jekyll | by Worg]]
 * [[http://xshaun.github.io/jekyll-bootstrap/2014/08/27/jekyllbootstrap5-jekyll-introduction][Jekyll简介及工作原理]]
 * [[https://segmentfault.com/a/1190000008313904][用Org-mode和Jekyll写博客]]

* 更新!
  :PROPERTIES:
  :ID:       6F5E248F-3BB0-49A4-92B5-A333F42CFAD6
  :PUBDATE:  <2020-02-11 Tue 14:32>
  :END:
** Oct 21, 2019
   :PROPERTIES:
   :ID:       012201B7-BC2D-4D46-8B8D-3FA647F1D926
   :END:
我的workflow使用了 [[https://huangxuan.me/][Hux Blog]] 默认的CSS，而默认的样式为markdown转html提供了相关样式支持，没有对org-mode的支持，这是需要添加“缺失样式“的原因。但是，这种方法太不优雅，并且我并不喜欢hux的默认样式。我希望自己可以控制整个org-mode导出效果，这样可以使用很多 [[https://emacs-china.org/t/org-mode-html/10120][漂亮的样式]] 来渲染orgmode。

#+BEGIN_SRC plaintext
.
├── bootstrap.css
├── bootstrap.min.css
├── hux-blog.css
├── hux-blog.min.css
└── my-org.css
#+END_SRC

以上为css目录的内容，hux-blog文件中存放了站点的所有样式，包括网站的基本结构和文章的渲染。

解决方法：
 * 找出默认hux-blog CSS中与文章渲染的相关css注释掉。在hux中，所有包含 =.post-container= 的样式为文章渲染样式。
 * 将用于orgmode导出渲染的 =my-org.css= 所有样式前面加上 =.post-container= 。
 * 在html的header中引入 =my-org.css= 样式文件。

以上方案，仅以hux为例，读者可以作为思路的参考。具体问题请具体分析。
</description>
<author>Kinney Zhang</author>
<pubDate>2019-09-03</pubDate>
</item>
<item>
<title>Emacs中使用mpd+mingus听音乐</title>
<link>https://blog.geekinney.com/post/listen-music-in-emacs.html</link>
<description>#+TITLE:  Emacs中使用mpd+mingus听音乐
#+DATE: 2019-08-31
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+CATEGORY: Emacs
#+INCLUDE: "../code/post-info.org"
#+TOC: headlines:2

在emacs中收听音乐的方案不止一个，我之前用过[[https://github.com/emacsmirror/emms][emms]]和[[https://github.com/dbrock/bongo][bongo]]，但它们在某些方面不能满足我的需求。在逛Reddit时看到使用mpd配合mingus播放音乐的帖子，折腾了一下发现这正是我想要的！总结安装配置和踩坑经验，和大家分享。

Music Player Daemon(mpd)是一个开源、灵活、功能强大的server端音乐播放器。它可以播放音乐、管理播放列表、维护音乐数据库等。mpd作为服务端程序，需要与客户端配合才能展现其强大的功能。最常使用的mpd客户端有mpc, ncmpcpp等。

而emacs的[[https://github.com/pft/mingus.git][mingus package]]就相当于mpd在emacs中的client端。下面介绍mpd和mingus的安装和使用。

* mpd安装及配置(macos)

** 安装
Mac用户可以很方便的使用homebrew安装mpd

#+BEGIN_SRC shell
$ brew install mpd
#+END_SRC

也可以到[[https://www.musicpd.org][MPD官网]]下载解压安装

** 创建配置文件
mpd默认的配置文件查找路经为 =~/.mpd/mpd.conf= 或 =~/.mpdconf= ，这里建议将所有配置及相关数据文件放在一个.mpd文件夹中。

#+BEGIN_SRC shell
  $ mkdir -p ~/.mpd/playlists
  $ touch ~/.mpd/{mpd.conf,mpd.db,mpd.log,mpd.pid,mpdstate}
#+END_SRC

** 编辑配置
进入 =~/.mpd/mpd.conf= ，粘贴如下配置

#+BEGIN_SRC TOML
music_directory "~/Music"  # 音乐文件目录
playlist_directory "~/.mpd/playlists"  # 播放列表目录
db_file "~/.mpd/mpd.db"  # 数据库
log_file "~/.mpd/mpd.log"  # 日志文件
pid_file "~/.mpd/mpd.pid"  # 进程文件
state_file "~/.mpd/mpdstate"  # 保存播放状态，下次继续播放
auto_update "yes"
auto_update_depth "2"
follow_outside_symlinks "yes"
follow_inside_symlinks "yes"

audio_output {
 type "osx"
 name "CoreAudio"
 mixer_type "software"
}

decoder {
 plugin "mp4ff"
 enabled "no"
}

bind_to_address "127.0.0.1"  # 服务器地址
port "6600"  # 服务器监听端口

audio_output {
 type "fifo"
 name "my_fifo"
 path "/tmp/mpd.fifo"
 format "44100:16:2"
 auto_resample "no"
 use_mmap "yes"
}
#+END_SRC

** 使用命令

#+BEGIN_SRC shell
  $ mpd  # 启动服务
  $ mpd --kill  # 杀死进程
  $ mpd update  # 更新
#+END_SRC

** 注意点
 * 本配置及安装过程仅适用于macos系统。
 * linux系统参考 [[https://wiki.archlinux.org/index.php/Music_Player_Daemon][arch-wiki/Music Player Daemon]]
 * 如果你连接了蓝牙耳机，初次启动mpd时建议断开连接，能够正常播放后再连接蓝牙。（防止音乐声音断断续续）

* mingus安装及使用

** 安装
mingus基本上是零配置，我只绑定了一个快捷键进入mingus主界面。

#+BEGIN_SRC emacs-lisp
  (use-package mingus
    :ensure t
    :defer t
    :bind (("C-c m" . mingus)))
#+END_SRC

** 使用
mingus功能十分强大，内置大量快捷键，可以一键满足音乐播放方方面面的需求。使用 =M-x mingus= 启动mingus后，便可使用这些快捷键。

mingus有三个主界面"Mingus Help", "Mingus", "Mingus Browser"，可以使用数字键 =1= =2= =3= 进行切换。"Mingus Help"是帮助信息界面，介绍了所有的快捷键使用。"Mingus"是播放列表界面。"Mingus Browser"是搜索浏览界面，可以在音乐目录下进行分类搜索，将歌曲添加到播放列表中。

具体功能使用查看"Mingus Help"，不再赘述。值得一提的是，对于同类别的歌曲可以使用 =C-x C-s= 保存为playlist, 下次可以一键load歌单到播放列表中。

* 效果
https://geekinney-1258820352.cos.ap-hongkong.myqcloud.com/geekblog/img/mingus.png
* 参考文档
  DEADLINE: <2020-04-30 Thu>
[[https://computingforgeeks.com/install-configure-mpd-ncmpcpp-macos][Install and configure mpd and ncmpcpp on MacOS]]
</description>
<author>Kinney Zhang</author>
<pubDate>2019-08-31</pubDate>
</item>
<item>
<title>Get Started With Emacs</title>
<link>https://blog.geekinney.com/post/get-started-with-emacs.html</link>
<description>#+TITLE:Get Started With Emacs 
#+DATE: 2019-08-18
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+CATEGORY: Emacs
#+INCLUDE: "../code/post-info.org"
#+TOC: headlines:2

#+begin_quote
懒猫说：“Emacs是开源社区的典范, 也是全球顶尖黑客的思想结晶。没有Emacs, 我真的不会这么多年坚持做开源软件。Emacs时刻提醒我, 这个世界上有太多太多的聪明人比我更勤奋和有趣, 它就像一个每天都在增长的金字塔, 只有自己不断努力, 才能看到顶尖黑客是怎么切磋的.”
#+end_quote

都说emacs的学习曲线很陡峭，我觉得这得看情况。对于程序员或乐于折腾的人，配置舒服的开发环境，编写自己的插件确实需要可观的时间成本。但对于普通的学习、办公人员，emacs也同样可以成为称手的效率工具。事实上，我一直觉得，计算机领域的很多工具与想法值得被更多的非程序员所了解并使用。比如说，emacs！

这是一个系列blog的开篇，我将从个人理解的角度介绍一些实用的emacs workflow。期望非程序员在日常办公学习中也能很好的使用这个“神之编辑器”。当然，对于初次了解emacs的程序员，这也可以作为一个很好的开始，并且我相信，你一定会爱上它的。happy hacking emacs!

自从入坑emacs，它几乎就成了我每天必用的app(or os?)。我主要用emacs来做笔记、敲代码、管理时间、管理目录、管理代码、听音乐和podcast、学英语、hacking emacs...

* 介绍

你一定很好奇，这个emacs究竟是个什么东西，竟然可以同时拥有如此多的功能。其实它并不神秘，从本质上说，emacs就是一个文本编辑器。我们熟悉的文本编辑器有word, vim, atom, vscode等。

简单的说，emacs能够实现以上很多的功能依赖于emacs-lisp语言，通过编写elisp程序可以定制几乎所有的功能。而很多的功能前人已经造好了轮子，这些轮子就是emacs的插件。比如，用于文本编辑、任务管理的org-mode；用于目录管理的dired-mode，用于git管理的magit等。各种编程语言都有自己的插件，python-mode, js2-mode, web-mode...

对于初学者，不需要学习elisp语言，可以克隆他人成熟的配置先用起来。当你对emacs足够了解，自然会想要学习elisp定制一些功能和编写自己的插件。这是一个水到渠成的过程。


* 安装

** 安装emacs

可以从 [[https://www.gnu.org/software/emacs/][GNU Emacs 官网]] 下载合适的版本。MacOS用户也可以通过homebrew安装。

#+BEGIN_SRC shell
$ brew cask install emacs
#+END_SRC


** 克隆配置文件

可以使用我的emacs配置。第一行代码是备份，防止自己的 =.emacs.d= 被覆盖(如果是初次接触emacs，则无所谓)。第二行代码是克隆配置文件夹.emacs.d到用户主目录。

#+BEGIN_SRC shell
$ mv ~/.emacs.d ~/.emacs.d.bak
$ git clone --depth=1 https://github.com/Kinneyzhang/.emacs.d.git ~/.emacs.d --recursive
#+END_SRC


如果你不知道如何使用命令行，一个简单的办法就是访问 [[https://github.com/Kinneyzhang/.emacs.d][.emacs.d]] ，点击 =Clone or download= 中的 =Download ZIP= 下载到本地，然后解压到用户主目录。

** 启动emacs
   等待所有package安装完毕。

* 使用

Emacs 快捷键基本中的基本是这几个：

 * C（ =Ctrl= 或者 =control= 键）
 * M（Meta，PC 中对应 =Alt= ，Mac 上对应 =option= ），Meta 键来自 Solaris，常见 PC 都不具备该键
 * S（uper，PC 对应 =Win= 键，Mac 对应 =command= ）

在 Emacs 中，快捷键通常都是多个快捷键的组合，在前面的快捷（或组合）通常称为 prefix key，比如最常用的 =C-x C-c= 的 prefix key 就是 =C-x= 。相同 prefix key 的快捷键在功能上通常都有相似之处。

** 常用快捷键
   * Ctrl + a：移到行首
   * Ctrl + e：移到行尾
   * Ctrl + p/n：光标上下移动
   * Ctrl + f：按字符前移（右向）
   * Ctrl + b：按字符后移（左向）
   * Meta + f：按单词前移（右向）
   * Meta + b：按单词后移（左向）
   * Ctrl + k：从光标处剪切至行尾
   * Ctrl + w：剪切
   * Meta + w: 复制
   * Ctrl + y：粘贴
   * Ctrl + g：取消输入

详细快捷键信息参见 [[https://caiorss.github.io/Emacs-Elisp-Programming/Keybindings.html][Emacs Key Bindings]]
</description>
<author>Kinney Zhang</author>
<pubDate>2019-08-18</pubDate>
</item>
<item>
<title>关于写日志</title>
<link>https://blog.geekinney.com/post/thinking-about-journaling.html</link>
<description>#+TITLE:关于写日志

#+DATE: 2019-08-05

#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+CATEGORY: 杂思
#+INCLUDE: "../code/post-info.org"
#+TOC: headlines:2

写日志的一个重要好处就是通过每日的反思不断调整，使得事情朝着正确的方向发展。正确的标准是什么？首先自己得舒心，如果事情越做越难受，大抵是什么方面出了问题；其次是对事情的进展是否起促进作用，意识具有主观能动性，正确的意识促进事物的发展，错误的意识阻碍事物的发展；再者，检查事情的现状与初衷是否相符，如果忘记了为何出发，如何知道去向何处。

写日志的目的是什么？日志，顾名思义，一日的记录。记录的内容可以涉及方方面面，大体可以分为虚实两方面，即经历与思考。记录的目的主要有几个方面：一、给生活留下印记，所以要尽可能的全面真实。二、作为写作的素材，每日的灵感是很宝贵的思想财富，大概率可以应用于将来的写作中。三、锻炼表达与语言组织能力，在缺少与人言语交流的情况下，写文字也可以很好的锻炼遣词造句和逻辑表达。四、抒发情绪与观点，大部分文学作品都带有作者强烈的自我意识与情绪表达，写作很好的满足了作者的表达需求。五、思考与反思，这是我写日志最主要的原因与动力，也是我认为的最有价值的属性。没有十全十美的人，人总要在不断反思与自我批判中成长。反思的反义词叫“浑浑噩噩”。

应该通过何种形式来组织日志？以自己最舒服，最喜欢的方式。日志不是博客、新闻或论文等，不需要考虑受众。怎么喜欢怎么来就行。

形式不受限制并不是意味着毫无限制。回顾写日志的目的，至少要清晰的描述事件，准确的表达观点。如果你想作为写作可以参考的素材，最好附上相关引用链接，介绍清楚来龙去脉。如果要锻炼文字表达能力，要求就更高了，注意句式，注意运用修辞与描写方法，内心活动什么的。切忌漫无目的的意识流。要求再高一点，写长文一定要列提纲；短文也要做到心中有框架。关于如何列提纲，参考 /这篇文章/ ，以后我也会总结这篇文章中的观点(好吧，原链接挂了，我也还没来得及总结...)。

如果你在没有做研究的情况下撰写文章观点，基本上是不可能全面的；即使全面了，某些内容也会随着时间的推移而过时。这就是为什么写日志的最后一步叫"revise"修改。都说好文章是改出来的，没毛病！
</description>
<author>Kinney Zhang</author>
<pubDate>2019-08-05</pubDate>
</item>
<item>
<title>关于大学计算机科学</title>
<link>https://blog.geekinney.com/post/thinking-about-cs-teaching-in-college.html</link>
<description>#+TITLE:关于大学计算机科学
#+DATE: 2019-08-02
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+CATEGORY: 杂思
#+INCLUDE: "../code/post-info.org"
#+TOC: headlines:2

我以为学习计算机科学的学生在刚进入大学的时候，学院学校就要让学生了解到这个学科的森林，而非树木。建立学科体系结构和了解学科本质对于学习相当重要。我指的不是像每个专业大一的导论课，讲解大学四年学习课程的基础内容，最后用一张考试卷评判知识点的掌握程度。

构建学生对于学科的森林的认识应当不是一般的大学老师可以胜任的。计算机科学体系庞杂，分支众多，能够站在一定的高度还原计算机科学本质的专家教授才能上好这堂大学专业第一课。换句话说，这门课对讲授者的要求很高，讲授的内容要直观又不失深度，严肃而充满乐趣。课堂的作业多以开放性的思考与探索为主。课程考核学生对专业的理解与思考。

要给学生树立学习的榜样。站得高才能看得远，看得见远方的美景才有去向远方的动力。新生对在校学习可以达到的高度，将来研究内容的深度，自己能够创造的价值是缺乏认知的。要相信每一个学生都想变得更好，前提是给学生看到远方并给予希望。

看得到未来的理想生活，了解了努力的方向，学生的心中便种下了一颗种子，用四年的时间让它发芽成长开花结果。一个人、两个人、一群人，人是环境的产物，一群人的行动会汇聚成强大的磁场，吸引周围更多的人加入这个积极的队伍。

多学一个知识不如多听一堂讲座，多做几道题目不如多写几篇思考。大学的课程不以知识技能为导向，多以思考理解为导向，以理解带动知识学习，这样学生的学习效率会不会有极大的提高？
</description>
<author>Kinney Zhang</author>
<pubDate>2019-08-02</pubDate>
</item>
<item>
<title>重拾阅读</title>
<link>https://blog.geekinney.com/post/pick-up-reading-after-read-the-moon-and-sixpence.html</link>
<description>#+TITLE:重拾阅读 
#+DATE: 2019-07-21
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+CATEGORY: 阅读
#+INCLUDE: "../code/post-info.org"
#+TOC: headlines:2

我相信，一本好书是值得反复阅读品鉴的。今天读完了《月亮与六便士》，想着应该写点什么，毕竟这是我时隔好久完整地读完一本书了。

对于很难坚持阅读的我来说，这一刻是有重要意义的。这意味着我过去很多年在阅读上的心结打开了，也宣告着以后我会以更加积极的心态与行动去拥抱阅读这件事。曾经有多少次的心血来潮，买了一本本书；曾经又有多少次下定决心，从读书笔记开始，庄严的进入阅读的殿堂；多少次拿起kindle，又多少次把它丢在宿舍的某个角落很久......

有多少次的坚持，就有多少次的放弃。一直以来，我都在思考探索着适合我的阅读方式，憧憬着像某位大师饱读群书，挥笔如有神。到头来发现，重要的不是形式，而是我的这颗心，我为什么要阅读。

以前阅读的目的很功利，想着读完一本书，自己的文笔就能有质的提升。看完一篇文章，就记录下里面的精彩句子，写上自己的收获与感悟。读每一句的时候都在揣摩文字背后的深意，学习遣词造句的技巧。可是，这样的阅读方式，太累了！坚持不了多久就放弃了，到头来发现不仅没有多少收获，反而因阅读这件事耗费了大量的精力。

如果阅读的过程如此的让人不堪其负，这不是阅读最初该有的模样！

说到这，暂且把对阅读的思考放一放，回到《月亮与六便士》这本书。

当翻到书的最后一页的时候，我有些茫然，心里有种说不出来的滋味。是一种意犹未尽?是期待着有更加传奇，震撼人心的事情发生?还是觉得自己没有完全读懂这本书？都有一点！在我们普通人看来斯特里克兰的人生是有传奇色彩的，这种传奇不是我们能够复刻但也远非不可触及的。如今在影视圈泛滥的一些修仙玄幻题材的作品讲诉的故事引人入胜，但观众也只是看着开心罢了，不会有人去效仿或者思考其背后的逻辑。但斯特里克兰的故事是实实在在的生活啊！任何一个现实中的人看到这样的故事，大抵上不会没有思考，不会不想去了解这样的人活着的逻辑吧。

关于斯特里克兰的故事其实并不复杂，我可以用很简短的一段话来概括：一个家庭美满，事业成功的证券经纪人，一夜之间抛弃一切，远走他乡，从伦敦到巴黎，追求他的画画梦想。他在巴黎穷困潦倒，吃尽苦头，勾引朋友的妻子导致她自杀。他对周围的一切都残忍冷酷，包括他自己。最终来到了南太平洋的一座小岛，娶妻生子，与世隔绝，终于创造出改写现代艺术史的不朽之作。可临终前却叮嘱自己的土著妻子一把火烧了自己的杰作......

上述文字是小说导读的内容，在开始阅读这本书之前你就会了解到主人公的一生，你或许会讨厌这样的人设，觉得他冷酷无情，毫无道德观念。没错，毛姆想要刻画的斯特里克兰正是这样的一个人。但请记住，他的无情不是自私，因为他对自己也这样！他所追求的是一种原始的美，一种对美的渴望与创造。这种渴望让他像着了魔一样忽视了一切的人，事，感受。我把这种状态理解为追求理想的理想主义。用通俗的话来说就是我们经常说的追寻自己的内心，不要太在意别人对你的评价！哦豁，多么耳熟能详的话，写过高中作文的你一定深谙这个道理，并且还会引经据典，阐述论证。但是人就是这样，知道不一定懂得，懂得不一定会践行。当现实中的你面对抉择的时候，早就把这些话抛诸脑后了吧。

人往往不是自己渴望成为的人，而是不得不成为的人。真正的痛苦不是不去追求，而是活着求而不得，守着错误的选择煎熬一生。这种时候你有斯特里克兰的勇气吗？你可以为了曾经的梦想去舍弃安定的生活吗？或者说反过来，你能够为了平淡的生活舍弃自己追寻的梦想吗？只要遵循自己的内心，月亮或者六个便士，无论你选那种，都是幸福的，这大概是这部小说想要告诉我们的吧。

什么是生活的意义？不是看到别人画画也去画画，不是听爸爸说，听老师说，听别人说你要做什么。这些没人能真正告诉你，需要你自己满怀勇气，去探索找寻。去问一问自己的心，我想要的究竟是什么。

回到阅读这件事。既然阅读的过程让我痛苦，那我为什么还要不断的尝试呢？爸爸妈妈老师说，你要多读书呀，腹有诗书才能写好作文。可事实证明抱着这样的心态去读书，我经历了一次次坚持后的放弃。何为读书的意义？我为什么要阅读？阅读时候的我为何无法享受其中？......我不断的拷问着自己的内心，不停的找寻思考。直到读完月亮与六便士，我以一种平静的心态，以一个局外人的目光去窥视主人公的一生，小心翼翼地走进斯特里克兰的生活。我会为他的离家出走愤懑不解，也会为他流落街头同情惋惜，我想要去探索他的精神世界，想要搞懂他的行为逻辑，想从小说的故事去思考自身，对应现实......一切都在阅读中不经意的进行。一直读到最后一页，长抒了一口气：真是，精彩！

这才是真正的享受阅读。

一本好书是值得反复阅读品鉴的，我想每年重读一遍《月亮与六便士》，这本畅销书中的经典。
</description>
<author>Kinney Zhang</author>
<pubDate>2019-07-21</pubDate>
</item>
<item>
<title>《子弹笔记》要点</title>
<link>https://blog.geekinney.com/post/reading-notes-of-bullet-journal.html</link>
<description>#+TITLE: 《子弹笔记》要点
#+DATE: 2019-03-05
#+STARTUP: showall
#+OPTIONS: toc:nil H:2 num:0
#+CATEGORY: 阅读
#+INCLUDE: "../code/post-info.org"

** 理论
    * 子弹短句分为三类：任务(Task，需要做的事情), 事件(Event，你的经历), 笔记(Note，不想遗忘的信息)
    * 任务子弹分类：任务(●), 完成的任务(x), 迁移的任务(>), 计划中的任务(<), 不想关的任务(+划去+)
    * 事件子弹：用“○”表示，简明客观的记录即将发生或已经发生的事件，方便日后回顾与解决问题
    * 笔记子弹：用“-”表示，当某件事情有重要或有趣的细节值得记录时使用
    * 优先符号：用“★”表示，用于标注重要的子弹短句，常于任务子弹搭配
    * 灵感符号：用"!"标注笔记子弹，表明这条笔记让我产生了想法，思考或见解，供后续整理
    * 集子：模块化的集子解决混乱。子弹笔记的四个核心集子：每日记录，月度记录，未来记录，索引
    * 每日记录：快速记录一天的任务，事件，笔记，让思想减负
    * 月度记录：分为日历页和任务页，日历页是事件发生的时间轴，任务页梳脑中所有思绪
    * 未来记录：每日记录中有未来之事迁移到未来记录中，月度记录的时候查看未来记录进行迁移
    * 月度迁移：回顾上月任务未完成情况，分成4中情况：1.舍弃 2.重新抄写 3.迁移到个性化集子 4.迁移到未来记录
    * 年度迁移：回顾上一年的未完成情况，考察迁移那些项目，集子

** 实践
    * 反思：日反思规划，夜反思回顾。
    * 意义：很多人把追求快乐当作人生目标，事实上快乐不可占有。当你达成某个目标或者得到你想要的生活后，你的快速适应会让你觉得平淡无奇，快乐感逐渐消退。快乐只是一种情绪，是我们着手进行其他目标时的结果。我们更应该关注怎么做，即寻找生活的意义。观察那些让你产生好奇心，那些“大放光芒”的事物，这些事物有可能具有意义。寻找这些事物的本质。
    * 目标：带意向的设定目标，目标的灵感可以来源与激情之源。创建目标集子，设定期限，分清主次，划去不必要的目标。分解长期目标为冲刺目标，分解前头脑风暴，每日反思 ，即时修正。
    * 循序渐进：实现目标的过程不要期待巨变，要持续改善。

** 好句摘录
    * 如果生活是大海，那么其中的每一天就像海浪一样，有的震撼，有的普通。子弹笔记就像海岸，在每一天的影响下得到雕琢。
    * 若没能把想法积极的运用到生活中，就算是最强烈的信仰，最有益的经验也会消散。
    * 无论一项行动有多么简单，其背后都蕴含了无数选择。
    * 眼睛只能看到光亮，耳朵只能听到声音，而一颗聆听的心却能感知到意义。
    * 好奇心是我们在看到某种潜能时产生的触电般的兴奋劲。好奇心点亮幻想与惊讶，就像磁铁一样，把我们从封闭的自我中拉出来，融入世界中，它超越理智、欲望、个人利益，甚至是快乐。
    * 享乐效应指当前环境的改变给人带来快乐时，人们通常会很快适应环境的改变，恢复到平常的快乐程度。
    * 快乐是我们着手进行其他目标时的结果。如果快乐是行为的结果，那我们就不该问自己如何才能快乐了。相反，我们该问问自己，要怎么做。
    * 作家克托尔.加西亚曾说：“你的ikigai即是你擅长的事，又是你热衷的事”。多年来，人们用许多不同的字眼和实践来描述这一点，但都殊途同归的回到生活意义的核心。
    * 感受那些“大放光芒”的事物，这些事物有可能具有意义。
    * 如果不带意向的胡乱设定目标，目标就有可能沦落为我们在遭遇龌蹉或悲痛时下意识的反应。
    * 获得干劲的一大妙招就是意识到时间有限。
    * 目标的灵感启发应当源自自身的生活经历。不论是带给你欢乐的积极动力还是带给你悲惨教训的生活苦难，你的生活中肯定有真正的激情之源。把这些经历运用起来，这些都是强有力的意义源泉，你可以从中找到有意义的目标。
    * 宏大的目标往往费时又费力，在这一路上你会面对各种挑战，耐力常常是你最狡猾最致命的对手。因此，要实现宏大的目标，常常需要切实的需求看来激励自己度过数日，数月，甚至数年的风风雨雨。这项需求必须足够强劲，才能抵御一路上的分心、借口和疑惑。
    * 这个世界上有天真的问题，乏味的问题，用词不当的问题，自我批评不足提出的问题。但每一次发问都是为了了解世界。这世界上没有愚蠢的问题。
</description>
<author>Kinney Zhang</author>
<pubDate>2019-03-05</pubDate>
</item>
<item>
<title>emacs学习笔记</title>
<link>https://blog.geekinney.com/post/emacs-learning-note.html</link>
<description>#+TITLE:emacs学习笔记 
#+DATE: 2019-03-02
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:0
#+CATEGORY: Emacs
#+INCLUDE: "../code/post-info.org"
#+TOC: headlines:2

* 文件操作
 * C-x d进入Dired-mode
 * + 新建文件夹
 * C-x C-f 新建文件
 * C 复制
 * D 删除
 * d 标记删除，x执行，u取消
 * R 重命名文件
 * C-x C-j 打开当前文件的目录
 * C-c p f 在当前git中查找

* 列表
#+begin_example
   1. [50%] 任务1
      - [X] t1
      - [ ] t2
   2. [1/3] 任务2
      - [ ] t1
      - [X] t2
      - [ ] t3
   3. [ ] 任务3
   4. [X] 任务4

#+end_example
   1. [50%] 任务1
      - [X] t1
      - [ ] t2
   2. [1/3] 任务2
      - [ ] t1
      - [X] t2
      - [ ] t3
   3. [ ] 任务3
   4. [X] 任务4

* 表格
 * C-c | 通过输入大小的方式插入表格
 * C-c C-c 对齐表格
 * Tab 调到右边一个表格
 * enter 跳到下方的表格
 * M-up/right/left/right 上下左右移动行（列）
 * M-S-up/right/left/right 移动当前行（列）,并插入空行

#+begin_example
| Name | Phone | sub1 | sub2 | total |
|------+-------+------+------+-------|
|kinney|  111  |  111 |  111 |  111  |
#+end_example

| Name | Phone | sub1 | sub2 | total |
|------+-------+------+------+-------|
|kinney|  111  |  111 |  111 |  111  |

* 链接
#+begin_example
  [[http://orgmode.org/orgguide.pdf]grgguid.pdf]]
  [[file:/Users/kinney/Desktop/屏幕快照\2018-08-10\19.33.36.png][链接写法]]
#+end_example
直接显示的图片在Emacs里默认不显示，需按C-c C-x C-v才能显示，在输出成其他格式（html、pdf……）后也能看到.常用快捷键:- C-c C-x C-v 直接预览图片。

* 待做列表
#+begin_example
*DONE [ ] 任务1
*TODO [#A] 任务2
#+end_example

一些常用操作如下： 
- C-c C-t 变换TODO的状态 
- C-c / t以树的形式展示所有的 TODO 
- C-c C-c 改变 checkbox状态 
- C-c, 设置优先级（方括号里的ABC） 
- M-S-RET 插入同级TODO标签

* 时间
输入C-c . 会出现一个日历，我们点选相应的时间即可插入。
#+begin_example
  DEADLINE: <2018-08-10 Fri>
  SCHEDULED: <2018-08-18 Sat>
#+end_example

* 特殊文本格式

#+begin_example
  *bold*
  /italic/ 
  _underline_
  =code=
  ~verbatim~
  +strike-through+
#+end_example
*bold* \\
/italic/ \\
_underline_ \\
=code= \\
~verbatim~ \\
+strike-through+
  
* 富文本导出
** 设置标题和目录
#+BEGIN_EXAMPLE
#+TITLE: This is the title of the document
#+OPTIONS: toc:2 (only to two levels in TOC)
#+OPTIONS: toc:nil (no TOC at all)
#+END_EXAMPLE
** 居中
#+begin_example
#+BEGIN_CENTER
这里是居中的内容
#+END_CENTER
 #+end_example

#+begin_center
这里是居中的内容
#+end_center

** 注释
#+begin_example
#+BEGIN_COMMENT
这里的注视不会被导出
#+END_COMMENT
#+end_example

   #+BEGIN_COMMENT
   这里的注视不会被导出
   #+END_COMMENT
** 分隔符
#+begin_example
------
#+end_example
------

** 引用
#+begin_example
#+BEGIN_QUOTE
这里是引用的内容
#+END_QUOTE
#+end_example

#+BEGIN_QUOTE
这里是引用的内容
#+END_QUOTE
** 多行换行
#+begin_example
#+BEGIN_VERSE
这里面的
每一行
都可以自动换行
#+END_VERSE
单行换行，在句尾加"\\"
#+end_example

#+BEGIN_VERSE
这里面的
每一行
都可以自动换行
#+END_VERSE

* org-clock
  * org-clock-in(C-c C-x C-i)
  * org-clock-out(C-c C-x C-o)
  * org-clock-display(C-c C-x C-d)
  * org-clock-cancle(C-c C-x C-q)
  * org-clock-report(C-c C-x C-r)
  * org-dblock-update(C-c C-c), 光标放在#+Begin位置

* 标题间跳转
  * C-c C-n / C-c C-p

* how to study emacs
  * https://emacs-china.org/t/emacs/7532/16?u=kinneyzhang

* 查找替换
  * M-%

* proced
  * 查看系统进程情况
  * m标记，x选择向进程发送的命令
  * 按键s前缀选择展现方式
</description>
<author>Kinney Zhang</author>
<pubDate>2019-03-02</pubDate>
</item>

</channel>
</rss>
