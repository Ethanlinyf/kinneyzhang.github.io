#+TITLE: 自动生成org blog辅助信息
#+DATE: 2020-02-21
#+CATEGORY: 博客
#+MACRO: wc (eval (my/word-count))
#+INCLUDE: "../code/post-info.org"
#+STARTUP: content
#+OPTIONS: toc:nil H:2 num:2
#+TOC: headlines:2

一篇博客文章除了标题、正文，还有一些辅助的信息，比如：日期，分类，字数等。使用orgmode生成html不会自动生成这些内容，于是想hack一下。折腾效果如博文开头的：[ 分类: {{{keyword(category)}}} / 日期: {{{date}}} / 字数: {{{wc}}} ]。

这里主要使用了orgMode的 [[https://orgmode.org/manual/Macro-Replacement.html][Macro Replacement]] 功能。我们可以在org文件开头定义宏，然后在正文需要的位置调用宏就可以实现辅助信息的插入。

例如，定义如下宏：

#+begin_example
#+MACRO: poem Rose is $1, violet's $2. Life's ordered: Org assists you.
#+end_example

其中，"poem"为宏的名称，后面的内容为宏的内容，"$1，$2"为参数。然后在合适的位置调用宏：

#+begin_example
{{{poem(red,blue)}}}
#+end_example

最终的结果是在调用宏的位置插入"Rose is red, violet's blue. Life's ordered: Org assists you."。相信这种功能也不难理解，类似于函数的定义与调用。

除了插入一串字符，预先在org文件开头定义的一些keyword可以直接调用。也可以在宏中调用elisp函数，实现更为复杂的功能。blog辅助信息的生成就依赖这两个功能。为了实现上面的效果，我在文章开头插入了如下的宏调用：

<<macro-replace>>
#+begin_example
#+begin_center
[ 分类: {{{keyword(category)}}} / 日期: {{{date}}} / 字数: {{{wc}}} ]
#+end_center
#+end_example

其中 ={{{date}}}= 直接调用了 =#+DATE:= 预定义的日期， ={{{keyword(category)}}}= 调用了 =#+CATEGORY:= 预定义的分类。这里要说明的是，对于orgmode已有的keyword，如"TITLE, AUTHOR, DATE"这些可以直接调用。自定义的keyword如"CATEGORY"需要定义为形如 ={{{keyword(category)}}}= 的格式。最后，文章的字数需要使用一个elisp函数统计，这里需要定义一个统计字数的宏：

#+begin_example
#+MACRO: wc (eval (my/word-count))
#+end_example

不难理解，这个宏执行了 =my/word-count= 这个函数，然后插入到“字数：”后面。这个统计字数的函数定义如下：

#+BEGIN_SRC emacs-lisp
;; count words
(defvar wc-regexp-chinese-char-and-punc
  (rx (category chinese)))
(defvar wc-regexp-chinese-punc
  "[。，！？；：「」『』（）、【】《》〈〉※—]")
(defvar wc-regexp-english-word
  "[a-zA-Z0-9-]+")

(defun my/word-count ()
  "「較精確地」統計中/日/英文字數。
- 文章中的註解不算在字數內。
- 平假名與片假名亦包含在「中日文字數」內，每個平/片假名都算單獨一個字（但片假
  名不含連音「ー」）。
- 英文只計算「單字數」，不含標點。
- 韓文不包含在內。

※計算標準太多種了，例如英文標點是否算入、以及可能有不太常用的標點符號沒算入等
。且中日文標點的計算標準要看 Emacs 如何定義特殊標點符號如ヴァランタン・アルカン
中間的點也被 Emacs 算為一個字而不是標點符號。"
  (interactive)
  (let* ((v-buffer-string
          (progn
            (if (eq major-mode 'org-mode) ; 去掉 org 文件的 OPTIONS（以#+開頭）
                (setq v-buffer-string (replace-regexp-in-string "^#\\+.+" ""
								(buffer-substring-no-properties (point-min) (point-max))))
              (setq v-buffer-string (buffer-substring-no-properties (point-min) (point-max))))
            (replace-regexp-in-string (format "^ *%s *.+" comment-start) "" v-buffer-string)))
                                        ; 把註解行刪掉（不把註解算進字數）。
         (chinese-char-and-punc 0)
         (chinese-punc 0)
         (english-word 0)
         (chinese-char 0))
    (with-temp-buffer
      (insert v-buffer-string)
      (goto-char (point-min))
      ;; 中文（含標點、片假名）
      (while (re-search-forward wc-regexp-chinese-char-and-punc nil :no-error)
        (setq chinese-char-and-punc (1+ chinese-char-and-punc)))
      ;; 中文標點符號
      (goto-char (point-min))
      (while (re-search-forward wc-regexp-chinese-punc nil :no-error)
        (setq chinese-punc (1+ chinese-punc)))
      ;; 英文字數（不含標點）
      (goto-char (point-min))
      (while (re-search-forward wc-regexp-english-word nil :no-error)
        (setq english-word (1+ english-word))))
    (setq chinese-char (- chinese-char-and-punc chinese-punc))
    ;;  (message
    ;;      (format "中日文字數（不含標點）：%s
    ;; 中日文字數（包含標點）：%s
    ;; 英文字數（不含標點）：%s
    ;; =======================
    ;; 中英文合計（不含標點）：%s"
    ;;              chinese-char chinese-char-and-punc english-word
    ;;              (+ chinese-char english-word)))
    (+ chinese-char english-word)))
#+END_SRC

OK，这样每次在org发布项目的时候就会自动添加日期、分类和统计字数了。但是，每次在写blog的时候都要在开头加上[[macro-replace][这一段内容]]实在是麻烦。可以将这些内容放在单独的文件中，然后用 =#+INCLUDE:= 引入。

我将它们放在 =post-info.org= 这个文件中，完整的内容是：

#+begin_example
#+MACRO: wc (eval (my/word-count))
#+begin_center
[ 分类: {{{keyword(category)}}} / 日期: {{{date}}} / 字数: {{{wc}}} ]
#+end_center
#+end_example

然后在文章开头加上 =#+INCLUDE: "../code/post-info.org"= 即可。

注意：如果宏定义中执行的函数需要参数，一定要注意参数必须是字符串类型。比如参数中传入一个list，这个list就变成了字符串。在函数执行前需要先 =(read <list>)= 将字符串转为列表。
